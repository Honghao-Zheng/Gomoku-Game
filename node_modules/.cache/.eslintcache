[{"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\index.js":"1","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\GomokuGame.jsx":"2","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\Board.jsx":"3","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\GameLogic.jsx":"4","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\HomePage.jsx":"5","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\gameplaypage\\PlayerVsPlayer.jsx":"6","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\Buttons.jsx":"7","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\gameplaypage\\ComputerVsComputer.jsx":"8","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\ShowText.jsx":"9","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\gameplaypage\\PlayerVsComputer.jsx":"10","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\RandomPlayer.jsx":"11","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\SharedData.jsx":"12","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\gameplaypage\\Simulation.jsx":"13","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\MinimaxAlg.jsx":"14","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\GAalgorithm.jsx":"15","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\AILogic\\MoveEvaluation.jsx":"16","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\AILogic\\Objects.jsx":"17","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\AILogic\\MoveSearch.jsx":"18","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\ChoicePage\\AIVsAIChoice.jsx":"19","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\ChoicePage\\PlayerVsAIChoice.jsx":"20","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\ChoicePage\\SimulationChoice.jsx":"21","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\AILogic\\MoveEvaluationNew.jsx":"22","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\GeneralLogic.jsx":"23","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\Testing\\minimax.jsx":"24","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\Testing\\moveEvaluationNoDF.jsx":"25"},{"size":200,"mtime":1656600084000,"results":"26","hashOfConfig":"27"},{"size":1882,"mtime":1661453129831,"results":"28","hashOfConfig":"27"},{"size":970,"mtime":1661386012240,"results":"29","hashOfConfig":"27"},{"size":6365,"mtime":1658104572000,"results":"30","hashOfConfig":"27"},{"size":979,"mtime":1659292474000,"results":"31","hashOfConfig":"27"},{"size":5720,"mtime":1659290924000,"results":"32","hashOfConfig":"27"},{"size":1974,"mtime":1661383073297,"results":"33","hashOfConfig":"27"},{"size":9596,"mtime":1661385958391,"results":"34","hashOfConfig":"27"},{"size":254,"mtime":1656539576000,"results":"35","hashOfConfig":"27"},{"size":9581,"mtime":1661382782694,"results":"36","hashOfConfig":"27"},{"size":1257,"mtime":1661386034568,"results":"37","hashOfConfig":"27"},{"size":2251,"mtime":1657662320000,"results":"38","hashOfConfig":"27"},{"size":11920,"mtime":1661440941964,"results":"39","hashOfConfig":"27"},{"size":3256,"mtime":1661388304550,"results":"40","hashOfConfig":"27"},{"size":9294,"mtime":1661386030077,"results":"41","hashOfConfig":"27"},{"size":10762,"mtime":1661386020484,"results":"42","hashOfConfig":"27"},{"size":362,"mtime":1658325768000,"results":"43","hashOfConfig":"27"},{"size":7112,"mtime":1661387940924,"results":"44","hashOfConfig":"27"},{"size":2482,"mtime":1658062206000,"results":"45","hashOfConfig":"27"},{"size":1964,"mtime":1658062336000,"results":"46","hashOfConfig":"27"},{"size":2535,"mtime":1658335568000,"results":"47","hashOfConfig":"27"},{"size":9904,"mtime":1661386009840,"results":"48","hashOfConfig":"27"},{"size":1249,"mtime":1661383107455,"results":"49","hashOfConfig":"27"},{"size":8679,"mtime":1661427379618,"results":"50","hashOfConfig":"27"},{"size":9945,"mtime":1661356827016,"results":"51","hashOfConfig":"27"},{"filePath":"52","messages":"53","suppressedMessages":"54","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},"46fdr6",{"filePath":"56","messages":"57","suppressedMessages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"59","messages":"60","suppressedMessages":"61","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"62","messages":"63","suppressedMessages":"64","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"65","messages":"66","suppressedMessages":"67","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"68","usedDeprecatedRules":"55"},{"filePath":"69","messages":"70","suppressedMessages":"71","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"72","usedDeprecatedRules":"55"},{"filePath":"73","messages":"74","suppressedMessages":"75","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"76","usedDeprecatedRules":"55"},{"filePath":"77","messages":"78","suppressedMessages":"79","errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"80","usedDeprecatedRules":"55"},{"filePath":"81","messages":"82","suppressedMessages":"83","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"84","messages":"85","suppressedMessages":"86","errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"87","usedDeprecatedRules":"55"},{"filePath":"88","messages":"89","suppressedMessages":"90","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"91","messages":"92","suppressedMessages":"93","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"94","messages":"95","suppressedMessages":"96","errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":null},{"filePath":"97","messages":"98","suppressedMessages":"99","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"100","messages":"101","suppressedMessages":"102","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"103","usedDeprecatedRules":"55"},{"filePath":"104","messages":"105","suppressedMessages":"106","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"107","usedDeprecatedRules":"55"},{"filePath":"108","messages":"109","suppressedMessages":"110","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"111","messages":"112","suppressedMessages":"113","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"114","usedDeprecatedRules":"55"},{"filePath":"115","messages":"116","suppressedMessages":"117","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"118","messages":"119","suppressedMessages":"120","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"121","messages":"122","suppressedMessages":"123","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"124","usedDeprecatedRules":"55"},{"filePath":"125","messages":"126","suppressedMessages":"127","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"128","usedDeprecatedRules":"55"},{"filePath":"129","messages":"130","suppressedMessages":"131","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"55"},{"filePath":"132","messages":"133","suppressedMessages":"134","errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"135","usedDeprecatedRules":"55"},{"filePath":"136","messages":"137","suppressedMessages":"138","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"139","usedDeprecatedRules":"55"},"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\index.js",[],[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\GomokuGame.jsx",["140","141","142"],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\Board.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\GameLogic.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\HomePage.jsx",["143"],[],"import React, { useState } from \"react\";\r\nimport {NavButton}  from \"./Buttons\";\r\n\r\n\r\nfunction HomePage(props){\r\n\r\n    return(\r\n        <div>\r\n\r\n            <div>\r\n                <NavButton \r\n                        text=\"Human VS Human \"\r\n                        onClick={()=>props.onClick(\"PvsP\")}\r\n                />\r\n            </div>\r\n\r\n            <div>\r\n                <NavButton \r\n                        text=\"Human VS Computer\"\r\n                        onClick={()=>props.onClick(\"PvsAI\")}\r\n                />\r\n            </div>\r\n\r\n            <div>\r\n                <NavButton \r\n                text=\"Computer VS Computer\"\r\n                onClick={()=>props.onClick(\"AIvsAI\")}\r\n                />\r\n            </div>\r\n\r\n            <div>\r\n                <NavButton \r\n                    text=\"Simulation\"\r\n                    onClick={()=>props.onClick(\"Simulation\")}\r\n                />\r\n            </div>\r\n\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default HomePage;","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\gameplaypage\\PlayerVsPlayer.jsx",["144"],[],"import Board from \"../Board\";\r\nimport {NavButton,FunctionButton} from \"../Buttons\";\r\n\r\nimport { putDownPiece, checkWinning,avalibleMoves } from \"../GameLogic\"\r\nimport { useState } from \"react\";\r\nimport ShowText from \"../ShowText\";\r\nimport moveEvaluation from \"../AIplayers/AILogic/MoveEvaluation\";\r\nlet boardArrangement=[\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]\r\n  ];\r\n\r\nfunction PlayerVsPlayer(props){\r\n    \r\n\r\n    const [turnState,setTurn]=useState({\r\n    isBlackTurn:true\r\n  });\r\n      const [gameState,setGame]=useState({\r\n        isEnded:false,\r\n        winner:null\r\n      })\r\n      const [moveState,setMove]=useState({\r\n        moveMade:[]\r\n      })\r\n    function handleMoveClick(clickedIntersectionCoord){\r\n      \r\n      let turn=turnState.isBlackTurn?\"B\":\"W\";\r\n      let isMoveMade;\r\n      let winner;\r\n\r\n      let avaMoves;\r\n      let numMoveLeft;\r\n\r\n      isMoveMade = putDownPiece(clickedIntersectionCoord,turn,boardArrangement);\r\n      if (isMoveMade){\r\n        // console.log(\"move score: \"+moveEvaluation(clickedIntersectionCoord,turn,0.9,boardArrangement).score)\r\n        avaMoves=avalibleMoves(boardArrangement);\r\n        numMoveLeft=avaMoves.length;\r\n        winner =checkWinning(turn,clickedIntersectionCoord,boardArrangement);\r\n        if (winner!==null){\r\n          setGame({\r\n            isEnded:true,\r\n            winner:winner\r\n          })\r\n        } else if(numMoveLeft===0){\r\n          setGame({\r\n            isEnded:true,\r\n            winner:\"D\"\r\n          })\r\n        }\r\n        \r\n        // console.log(moveState.moveMade)\r\n        setMove({moveMade:clickedIntersectionCoord})\r\n        setTurn({isBlackTurn:turnState.isBlackTurn?false:true});\r\n      } \r\n    }\r\n\r\n    function getWinningDeclaration(whowin){\r\n        if (whowin===\"B\"){\r\n            return (\"Black piece win !\")\r\n        } else if(whowin===\"W\" ){\r\n            return (\"White piece win !\")\r\n        } else if (whowin===\"D\" ){\r\n            return (\"Game Draw\")\r\n        }\r\n    }\r\n\r\n    function resetBoard(board){\r\n        let rowIndex,colIndex;\r\n        for (rowIndex=0;rowIndex<board.length;rowIndex++){\r\n          for (colIndex=0;colIndex<board[rowIndex].length;colIndex++){\r\n            if(board[rowIndex][colIndex]!==\" \"){\r\n                board[rowIndex][colIndex]=\" \"\r\n            }\r\n          }\r\n                   \r\n        }\r\n    }\r\n\r\n    function resetGame(board){\r\n        resetBoard(board)\r\n        setTurn({isBlackTurn:true})\r\n        setGame({isEnded:false, winner:null})\r\n        setMove({moveMade:[]})\r\n    }\r\n\r\n    function returnHome(board){\r\n      props.onClickHome();\r\n      resetGame(board)\r\n    }\r\n\r\n\r\n    // console.log(gameState.isEnded)\r\n    // console.log(gameState.winner)\r\n    // console.log(boardArrangement1vs1)\r\n    return(\r\n        <div>\r\n        <div className=\"rows\">\r\n        <NavButton text=\"Home\" onClick={()=>{\r\n                returnHome(boardArrangement)\r\n            }}/>\r\n\r\n            <h1>Player 1 VS Player 2</h1>\r\n        </div>\r\n        \r\n\r\n        <div className=\"gameScreen\">\r\n\r\n                <div className=\"gameboard\">        \r\n                    <Board\r\n                        boardArrangement={boardArrangement}\r\n                        onClick={gameState.isEnded?\r\n                                    null:\r\n                                    ([rowNum,colNum])=>handleMoveClick([rowNum,colNum])}\r\n                        moveMade={moveState.moveMade}\r\n                        />\r\n                </div>\r\n                <div className=\"des\">\r\n                \r\n                    <FunctionButton text=\"reset\" onClick={()=>resetGame(boardArrangement)}/>\r\n                    {\r\n                    gameState.isEnded?\r\n                    <ShowText textColour=\"textRed\"\r\n                        condition={gameState.isEnded}\r\n                        textIfTrue={getWinningDeclaration(gameState.winner)}\r\n                        textIfFalse=\"\"\r\n                     />:\r\n                   <ShowText textColour=\"textBlack\"\r\n                        condition={turnState.isBlackTurn}\r\n                        textIfTrue=\"Turn: Black\"\r\n                        textIfFalse=\"Turn: White\"\r\n                    />\r\n                    }\r\n                    <ShowText textColour=\"textBlack\"\r\n                        condition={true}\r\n                        textIfTrue=\"Black Piece: Player 1\"\r\n                        textIfFalse=\"\"\r\n                    />\r\n                       <ShowText textColour=\"textBlack\"\r\n                        condition={true}\r\n                        textIfTrue=\"white Piece: Player 2\"\r\n                        textIfFalse=\"\"\r\n                    />                  \r\n                </div>\r\n\r\n        </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default PlayerVsPlayer;","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\Buttons.jsx",["145","146"],[],"//jshint esversion:6\r\nimport React, { Component } from \"react\";\r\n\r\n//the component, \"intersection\", is from my previous personal project, and it can\r\n// be found on github.com/Honghao-Zheng\r\nfunction Intersection(props) {\r\n  let selectedPiece=props.piece;\r\n  let cellColour=props.colour;\r\n  return (\r\n    <button className={\"square \"+cellColour+\" \"+selectedPiece} onClick={props.onClick}>\r\n\r\n    </button>\r\n  );\r\n}\r\n\r\nfunction StartAIvsAI(props) {\r\n  let selectedPiece=props.piece;\r\n  let cellColour=props.colour;\r\n\r\n  return (\r\n    <button className={\"square \"+cellColour+\" \"+selectedPiece} onClick={props.onClick}>\r\n\r\n    </button>\r\n  );\r\n}\r\n\r\nfunction NavButton(props){\r\n  return (\r\n    <button className={\"navigation\"} onClick={props.onClick}>{props.text}</button>\r\n  )\r\n}\r\n\r\nfunction FunctionButton(props){\r\n  return (\r\n    <button className={\"function\"} onClick={props.onClick}>{props.text}</button>\r\n    )\r\n  \r\n}\r\n\r\n\r\nfunction RadioButtons(props) {\r\n  let values = props.values;\r\n  let groupName = props.groupName;\r\n  let defaultValue=props.defaultValue;\r\n\r\n  return (\r\n    <div onChange={(event)=>{\r\n      props.changeSetting(event.target.value)\r\n    }} className=\"radioDis\">\r\n    <div className=\"cols\">\r\n        {groupName}\r\n    </div>\r\n      {values.map((lable, index) => {\r\n        return (\r\n          <div className=\"cols\">\r\n            <p1> {lable}</p1>\r\n            <input type=\"radio\" value={lable} name={groupName} checked={lable===defaultValue}/>\r\n          </div>\r\n        );\r\n      })}\r\n    </div>\r\n  );\r\n}\r\n\r\n{/* <div onChange={onChangeValue} className=\"rows\">\r\n\r\n<div className=\"cols\">\r\n<p1> Male</p1>\r\n<input type=\"radio\" value=\"Male\" name=\"gender\" />\r\n</div>\r\n<div className=\"cols\">\r\n<p1>Female </p1>\r\n<input type=\"radio\" value=\"Female\" name=\"gender\" /> \r\n</div>\r\n<div className=\"cols\">\r\n<p1>Other </p1>\r\n<input type=\"radio\" value=\"Other\" name=\"gender\" />\r\n\r\n</div> */}\r\n\r\nexport {StartAIvsAI,Intersection,FunctionButton,NavButton,RadioButtons} \r\n\r\n\r\n","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\gameplaypage\\ComputerVsComputer.jsx",["147","148"],[],"\r\n\r\nimport Board from \"../Board\";\r\nimport {NavButton,FunctionButton} from \"../Buttons\";\r\nimport {chooseRandomMove} from \"../AIplayers/RandomPlayer\"\r\nimport { putDownPiece, checkWinning,avalibleMoves } from \"../GameLogic\"\r\nimport { useState } from \"react\";\r\nimport ShowText from \"../ShowText\";\r\nimport GAmove from \"../AIplayers/GAalgorithm\"\r\nimport minimaxMove from \"../AIplayers/MinimaxAlg\"\r\nimport {initdrawCheckBoard,drawCheckBoard} from \"../SharedData\";\r\nlet boardArrangement=[\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]\r\n  ];\r\n  let defaultMinimaxDepth=4;\r\nlet defaultGeneticDepth=4;\r\n  let minimaxDepth=defaultMinimaxDepth;\r\n  let geneticDepth=defaultGeneticDepth;\r\n  // boardArrangement=drawCheckBoard();\r\nfunction ComputerVsComputer(props){\r\n    let whoPlaysFirst=\"Computer 1\";\r\n    let AI1=props.settings.computer1;    \r\n    let AI2=props.settings.computer2;  \r\n    let AI1PieceColour;\r\n    let textBlackC1,textBlackC2,textWhiteC1,textWhiteC2;\r\n    // if (whoPlaysFirst===\"Computer 1\"){\r\n      AI1PieceColour=\"B\";\r\n      textBlackC1=\"Black Piece: Computer 1 (\"+AI1+\")\";\r\n      textWhiteC2=\"White Piece: Computer 2 (\"+AI2+\")\";\r\n    // } else {AI1PieceColour=\"W\"}\r\n    textBlackC2=\"Black Piece: Computer 2 (\"+AI2+\")\";\r\n    textWhiteC1=\"White Piece: Computer 1 (\"+AI1+\")\";\r\n    const [turnState,setTurn]=useState({\r\n    isBlackTurn:true\r\n  });\r\n      const [gameState,setGame]=useState({\r\n        isStarted:false,\r\n        isEnded:false,\r\n        winner:null\r\n      })\r\n      const [moveState,setMove]=useState({\r\n        moveMade:[]\r\n      })\r\n\r\n\r\n\r\n    function AImakeMove(AI,turn,board){\r\n        let computerMove;\r\n        if(AI===\"Random\"){\r\n            computerMove=chooseRandomMove(board)\r\n        } else if(AI===\"Minimax\") {\r\n          computerMove=minimaxMove(turn,0,minimaxDepth,board)\r\n        } else if(AI===\"MinimaxBad\") {\r\n          computerMove=minimaxMove(turn,0,1,board)\r\n        }else if(AI===\"Genetic\"){\r\n            computerMove=GAmove(geneticDepth,turn,board)\r\n        }else if(AI===\"GeneticBad\"){\r\n          computerMove=GAmove(1,turn,board)\r\n      }\r\n        putDownPiece(computerMove,turn,board)\r\n        return computerMove\r\n    } \r\n    function handleMoveClick(clickedIntersectionCoord){\r\n        let AIalgorithm;\r\n      let turn=turnState.isBlackTurn?\"B\":\"W\";\r\n      let whoWin;\r\n      let avaMoves;\r\n      let numMoveLeft\r\n\r\n//if it is AI1's turn, then use AI1's algorithm\r\n      if(AI1PieceColour===turn){\r\n        AIalgorithm=AI1;\r\n        } else{\r\n        AIalgorithm=AI2;\r\n        } \r\n      \r\n\r\n        // console.log(moveState.moveMade)\r\n        // setTurn({isBlackTurn:turnState.isBlackTurn?false:true});\r\n\r\n      let moveMade=AImakeMove(AIalgorithm,turn,boardArrangement)\r\n      // console.log(\"turn: \"+turn)\r\n      // console.log(\"atkThreats: \"+moveEvaluation(moveMade,turn,0.9,boardArrangement).atkThreats)\r\n      // console.log(\"defThreats: \"+moveEvaluation(moveMade,turn,0.9,boardArrangement).defThreats)\r\n      avaMoves=avalibleMoves(boardArrangement);\r\n      numMoveLeft=avaMoves.length;\r\n      whoWin =checkWinning(turn,moveMade,boardArrangement);\r\n      if (whoWin!==null){\r\n        setGame({\r\n            isStarted:gameState.isStarted,\r\n          isEnded:true,\r\n          winner:whoWin\r\n        })\r\n      }else if(numMoveLeft===0){\r\n        setGame({\r\n          isStarted:gameState.isStarted,\r\n          isEnded:true,\r\n          winner:\"D\"\r\n        })\r\n      };\r\n      setMove({moveMade:moveMade})\r\n      setTurn({isBlackTurn:turnState.isBlackTurn?false:true})\r\n      if(numMoveLeft<geneticDepth+1){\r\n\r\n        geneticDepth=numMoveLeft\r\n        // console.log(\"depth: \"+depth)\r\n    }\r\n    // console.log(\"numMoveLeft: \"+numMoveLeft)\r\n    // console.log(\"minimaxDepth: \"+minimaxDepth)\r\n    if(numMoveLeft<minimaxDepth+1){\r\n      minimaxDepth=numMoveLeft\r\n\r\n      // console.log(\"depth: \"+depth)\r\n  }\r\n      \r\n    }\r\n    function returnHome(board){\r\n      props.onClickHome();\r\n      resetGame(board)\r\n    }\r\n    function getWinningDeclaration(whowin){\r\n        if (whowin===\"B\"){\r\n            return (\"Black piece win !\")\r\n        } else if(whowin===\"W\" ){\r\n            return (\"White piece win !\")\r\n        } else if (whowin===\"D\" ){\r\n            return (\"Game Draw\")\r\n        }\r\n    }\r\n\r\n    function resetBoard(board){\r\n        let rowIndex,colIndex;\r\n        for (rowIndex=0;rowIndex<board.length;rowIndex++){\r\n          for (colIndex=0;colIndex<board[rowIndex].length;colIndex++){\r\n            if(board[rowIndex][colIndex]!==\" \"){\r\n                board[rowIndex][colIndex]=\" \"\r\n            }\r\n          }\r\n                   \r\n        }\r\n    }\r\n\r\n    function resetGame(board){\r\n        resetBoard(board)\r\n        setTurn({isBlackTurn:true})\r\n        setGame({isStarted:false, isEnded:false, winner:null})\r\n        setMove({moveMade:[]})\r\n        minimaxDepth=defaultMinimaxDepth;\r\n        geneticDepth=defaultGeneticDepth;\r\n    }\r\n\r\n    function resetAndStart(board, whoPlaysFirst){\r\n      resetGame(board);\r\n      startGame(whoPlaysFirst)\r\n    }\r\n\r\n    function startGame(whoPlaysFirst){\r\n        // console.log(whoPlaysFirst)\r\n        // console.log(AI1)\r\n        // console.log(AI2)\r\n        \r\n\r\n        if(whoPlaysFirst===\"Computer 1\"){          \r\n            let moveMade=AImakeMove(AI1,\"B\",boardArrangement)\r\n            // console.log(moveMade)\r\n            setMove({moveMade:moveMade});\r\n            setTurn({isBlackTurn:turnState.isBlackTurn?false:true});    \r\n\r\n        } else if(whoPlaysFirst===\"Computer 2\"){\r\n            let moveMade=AImakeMove(AI2,\"B\",boardArrangement)\r\n            // console.log(moveMade)\r\n            setMove({moveMade:moveMade});\r\n            setTurn({isBlackTurn:turnState.isBlackTurn?false:true}); \r\n        }\r\n        setGame({\r\n            isStarted:true,isEnded:false,winner:null\r\n        })\r\n\r\n    }\r\n\r\n\r\n\r\n    function isGamePlayEnabled(){\r\n        if(!gameState.isEnded && gameState.isStarted){\r\n            return true\r\n        } else {\r\n            return false\r\n        }\r\n    }\r\n\r\n    // console.log(gameState.isEnded)\r\n    // console.log(gameState.winner)\r\n    // console.log(boardArrangement1vs1)\r\n    return(\r\n        <div>\r\n        <div className=\"rows\">\r\n        <NavButton text=\"Home\" onClick={()=>{\r\n                returnHome(boardArrangement)\r\n            }}/>\r\n\r\n            <h1>Computer VS Computer</h1>\r\n        </div>\r\n        \r\n\r\n        <div className=\"gameScreen\">\r\n\r\n                <div className=\"gameboard\">        \r\n                    <Board\r\n                        boardArrangement={boardArrangement}\r\n                        onClick={isGamePlayEnabled()?\r\n                            ([rowNum,colNum])=>handleMoveClick([rowNum,colNum]):\r\n                                    null}\r\n                        moveMade={moveState.moveMade}\r\n                        />\r\n                </div>\r\n                <div className=\"des\">\r\n                \r\n                    {gameState.isStarted?\r\n                    <FunctionButton text=\"reset\" onClick={()=>resetAndStart(boardArrangement,whoPlaysFirst)}/>:\r\n                    <FunctionButton text=\"start\" onClick={()=>{\r\n                        startGame(whoPlaysFirst)\r\n                    }} />\r\n                    }\r\n                    {\r\n                    gameState.isEnded?\r\n                    <ShowText textColour=\"textRed\"\r\n                        condition={gameState.isEnded}\r\n                        textIfTrue={getWinningDeclaration(gameState.winner)}\r\n                        textIfFalse=\"\"\r\n                     />:\r\n                   <ShowText textColour=\"textBlack\"\r\n                        condition={turnState.isBlackTurn}\r\n                        textIfTrue=\"Turn: Black\"\r\n                        textIfFalse=\"Turn: White\"\r\n                    />\r\n                    }\r\n                    <ShowText textColour=\"textBlack\"\r\n                        condition={whoPlaysFirst===\"Computer 1\"}\r\n                        textIfTrue={textBlackC1}\r\n                        textIfFalse={textBlackC2}\r\n                    />\r\n                       <ShowText textColour=\"textBlack\"\r\n                        condition={whoPlaysFirst!==\"Computer 1\"}\r\n                        textIfTrue={textWhiteC1}\r\n                        textIfFalse={textWhiteC2}\r\n                    />        \r\n                                        <FunctionButton text=\"make a move\" \r\n                     onClick={isGamePlayEnabled()?\r\n                            ()=>handleMoveClick([0,0]):\r\n                                    null}/>:                \r\n                </div>\r\n\r\n        </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default ComputerVsComputer;","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\ShowText.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\gameplaypage\\PlayerVsComputer.jsx",["149","150","151"],[],"\r\n\r\nimport Board from \"../Board\";\r\nimport {NavButton,FunctionButton} from \"../Buttons\";\r\nimport {chooseRandomMove} from \"../AIplayers/RandomPlayer\"\r\nimport { putDownPiece, checkWinning,avalibleMoves } from \"../GameLogic\";\r\nimport { useState } from \"react\";\r\nimport ShowText from \"../ShowText\";\r\nimport GAmove from \"../AIplayers/GAalgorithm\";\r\nimport {initdrawCheckBoard,drawCheckBoard} from \"../SharedData\";\r\nimport minimaxMove from \"../AIplayers/MinimaxAlg\";\r\nimport moveEvaluation from \"../AIplayers/AILogic/MoveEvaluation\";\r\n\r\nlet boardArrangement=[\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"],\r\n    [\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \",\" \"]\r\n  ];\r\n  // boardArrangement=drawCheckBoard();\r\nlet defaultGeneticDepth=4;\r\nlet defaultMinimaxDepth=4\r\nlet minimaxDepth=defaultMinimaxDepth;\r\nlet geneticDepth=defaultGeneticDepth;\r\nfunction PlayerVsComputer(props){\r\n    let whoPlaysFirst=props.settings.whoGoFirst;\r\n    let AIalgorithm=props.settings.computer;    \r\n\r\n    const [turnState,setTurn]=useState({\r\n    isBlackTurn:true\r\n  });\r\n      const [gameState,setGame]=useState({\r\n        isStarted:false,\r\n        isEnded:false,\r\n        winner:null\r\n      })\r\n      const [moveState,setMove]=useState({\r\n        moveMade:[]\r\n      })\r\n    //   const [depth,setDepth]=useState({\r\n    //     num:5\r\n    //   })\r\n    \r\n\r\n\r\n\r\n    function AImakeMove(AI,turn,board){\r\n        let computerMove;\r\n        if(AI===\"Random\"){\r\n            computerMove=chooseRandomMove(board)\r\n        } else if(AI===\"Minimax\") {\r\n          computerMove=minimaxMove(turn,0,minimaxDepth,board)\r\n        } else if(AI===\"MinimaxBad\") {\r\n          computerMove=minimaxMove(turn,0,1,board)\r\n        }\r\n        else if(AI===\"Genetic\"){\r\n            computerMove=GAmove(geneticDepth,turn,board)\r\n        }\r\n        else if(AI===\"GeneticBad\"){\r\n            computerMove=GAmove(1,turn,board)\r\n        }\r\n        putDownPiece(computerMove,turn,board)\r\n        \r\n        return computerMove\r\n    } \r\n    function handleMoveClick(clickedIntersectionCoord){\r\n      \r\n      let turn=turnState.isBlackTurn?\"B\":\"W\";\r\n      let isMoveMade;\r\n      let whoWin;\r\n    let avaMoves;\r\n    let numMoveLeft;\r\n    let moveMade;\r\n    let isGameEnded=false;\r\n      isMoveMade = putDownPiece(clickedIntersectionCoord,turn,boardArrangement);\r\n      moveMade=clickedIntersectionCoord;\r\n      if (isMoveMade){\r\n        \r\n        whoWin =checkWinning(turn,clickedIntersectionCoord,boardArrangement);\r\n        avaMoves=avalibleMoves(boardArrangement);\r\n        numMoveLeft=avaMoves.length;\r\n        if (whoWin!==null){\r\n          setGame({\r\n            isStarted:gameState.isStarted,\r\n            isEnded:true,\r\n            winner:whoWin\r\n          })\r\n          isGameEnded=true;\r\n        }else if(numMoveLeft===0){\r\n            setGame({\r\n              isEnded:true,\r\n              winner:\"D\"\r\n            })\r\n            isGameEnded=true;\r\n          };\r\n        // console.log(moveState.moveMade)\r\n        // setTurn({isBlackTurn:turnState.isBlackTurn?false:true});\r\n        if(turn===\"B\"){\r\n            turn=\"W\"\r\n        }else{\r\n            turn=\"B\"\r\n        }\r\n        // console.log(\"numMoveLeft: \"+numMoveLeft)\r\n        // console.log(\"depth: \"+depth)\r\n        \r\n        if(numMoveLeft<geneticDepth+1){\r\n\r\n            geneticDepth=numMoveLeft\r\n            // console.log(\"depth: \"+depth)\r\n        }\r\n        // console.log(\"numMoveLeft: \"+numMoveLeft)\r\n        // console.log(\"minimaxDepth: \"+minimaxDepth)\r\n        if(numMoveLeft<minimaxDepth+1){\r\n          minimaxDepth=numMoveLeft\r\n\r\n          // console.log(\"depth: \"+depth)\r\n      }\r\n      // console.log(\"numMoveLeft: \"+numMoveLeft)\r\n      // console.log(\"minimaxDepth: \"+minimaxDepth)\r\n      // numMoveLeft-=1;\r\n        if(!isGameEnded){\r\n            moveMade=AImakeMove(AIalgorithm,turn,boardArrangement)\r\n            whoWin =checkWinning(turn,moveMade,boardArrangement);\r\n            avaMoves=avalibleMoves(boardArrangement);\r\n            numMoveLeft=avaMoves.length;\r\n            if (whoWin!==null){\r\n              setGame({\r\n                  isStarted:gameState.isStarted,\r\n                isEnded:true,\r\n                winner:whoWin\r\n              })\r\n            }  else if(numMoveLeft===0){\r\n              setGame({\r\n              isStarted:gameState.isStarted,\r\n                isEnded:true,\r\n                winner:\"D\"\r\n              })\r\n\r\n            }\r\n        }\r\n\r\n      setMove({moveMade:moveMade})\r\n      } \r\n    }\r\n\r\n    function getWinningDeclaration(whowin){\r\n        if (whowin===\"B\"){\r\n            return (\"Black piece win !\")\r\n        } else if(whowin===\"W\" ){\r\n            return (\"White piece win !\")\r\n        } else if (whowin===\"D\" ){\r\n            return (\"Game Draw\")\r\n        }\r\n    }\r\n    function resetAndStart(board, whoPlaysFirst){\r\n      resetGame(board);\r\n      startGame(whoPlaysFirst)\r\n    }\r\n    function resetBoard(board){\r\n        let rowIndex,colIndex;\r\n        for (rowIndex=0;rowIndex<board.length;rowIndex++){\r\n          for (colIndex=0;colIndex<board[rowIndex].length;colIndex++){\r\n            if(board[rowIndex][colIndex]!==\" \"){\r\n                board[rowIndex][colIndex]=\" \"\r\n            }\r\n          }\r\n                   \r\n        }\r\n    }\r\n\r\n    function resetGame(board){\r\n        resetBoard(board)\r\n        setTurn({isBlackTurn:true})\r\n        setGame({isStarted:false, isEnded:false, winner:null})\r\n        setMove({moveMade:[]})\r\n        minimaxDepth=defaultMinimaxDepth;\r\n        geneticDepth=defaultGeneticDepth;\r\n    }\r\n\r\n    function returnHome(board){\r\n      props.onClickHome();\r\n      resetGame(board)\r\n    }\r\n\r\n    function startGame(whoPlaysFirst){\r\n        if(whoPlaysFirst!==\"Player\"){          \r\n            let moveMade=AImakeMove(AIalgorithm,\"B\",boardArrangement)\r\n            // console.log(moveMade)\r\n            setMove({moveMade:moveMade});\r\n            setTurn({isBlackTurn:turnState.isBlackTurn?false:true});    \r\n\r\n        }\r\n        setGame({\r\n            isStarted:true,isEnded:false,winner:null\r\n        })\r\n    }\r\n\r\n    function isGamePlayEnabled(){\r\n        if(!gameState.isEnded && gameState.isStarted){\r\n            return true\r\n        } else {\r\n            return false\r\n        }\r\n    }\r\n\r\n    // console.log(gameState.isEnded)\r\n    // console.log(gameState.winner)\r\n    // console.log(boardArrangement1vs1)\r\n    return(\r\n        <div>\r\n        <div className=\"rows\">\r\n        <NavButton text=\"Home\" onClick={()=>{\r\n                returnHome(boardArrangement)\r\n            }}/>\r\n\r\n            <h1>Human VS Computer</h1>\r\n        </div>\r\n        \r\n\r\n        <div className=\"gameScreen\">\r\n\r\n                <div className=\"gameboard\">        \r\n                    <Board\r\n                        boardArrangement={boardArrangement}\r\n                        onClick={isGamePlayEnabled()?\r\n                            ([rowNum,colNum])=>handleMoveClick([rowNum,colNum]):\r\n                                    null}\r\n                        moveMade={moveState.moveMade}\r\n                        />\r\n                </div>\r\n                <div className=\"des\">\r\n                \r\n                    {gameState.isStarted?\r\n                    <FunctionButton text=\"reset\" onClick={()=>resetAndStart(boardArrangement,whoPlaysFirst)}/>:\r\n                    <FunctionButton text=\"start\" onClick={()=>{\r\n                        startGame(whoPlaysFirst)\r\n                    }} />\r\n                    }\r\n                    {\r\n                    gameState.isEnded?\r\n                    <ShowText textColour=\"textRed\"\r\n                        condition={gameState.isEnded}\r\n                        textIfTrue={getWinningDeclaration(gameState.winner)}\r\n                        textIfFalse=\"\"\r\n                     />:\r\n                   <ShowText textColour=\"textBlack\"\r\n                        condition={turnState.isBlackTurn}\r\n                        textIfTrue=\"Turn: Black\"\r\n                        textIfFalse=\"Turn: White\"\r\n                    />\r\n                    }\r\n                    <ShowText textColour=\"textBlack\"\r\n                        condition={whoPlaysFirst===\"Player\"}\r\n                        textIfTrue=\"Black Piece: Player (Human)\"\r\n                        textIfFalse={\"Black Piece: Computer(\"+AIalgorithm+\")\"}\r\n                    />\r\n                       <ShowText textColour=\"textBlack\"\r\n                        condition={whoPlaysFirst!==\"Player\"}\r\n                        textIfTrue=\"White Piece: Player (Human)\"\r\n                        textIfFalse={\"White Piece: Computer(\"+AIalgorithm+\")\"}\r\n                    />                  \r\n                </div>\r\n\r\n        </div>\r\n        </div>\r\n    )\r\n}\r\n\r\nexport default PlayerVsComputer;","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\RandomPlayer.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\SharedData.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\gameplaypage\\Simulation.jsx",["152","153","154","155","156","157","158","159","160","161","162"],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\MinimaxAlg.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\GAalgorithm.jsx",["163"],[],"// import moveEvaluation from \"./AILogic/MoveEvaluation\";\r\n// import moveEvaluation from \"./AILogic/MoveEvaluationGenetic\";\r\nimport moveEvaluation from \"./AILogic/MoveEvaluationNew\";\r\nimport {individual} from \"./AILogic/Objects\";\r\nimport {swapColor,putDownPiece} from \"../GameLogic.jsx\"\r\nimport {copyTwoDimArray,random,shuffle} from \"../GeneralLogic.jsx\"\r\nimport {movesSearchGA} from \"./AILogic/MoveSearch\";\r\nimport {chooseRandomMoveInit} from \"./RandomPlayer\";\r\nfunction initIndMoves(turn,depth,board){\r\n    let boardCopy=copyTwoDimArray(board)\r\n    let move;\r\n    let possibleMoves;\r\n    let numOfMoves;\r\n    let d;\r\n    let moveIndex;\r\n    let individualMoves=[];\r\n    possibleMoves=movesSearchGA(boardCopy)\r\n    numOfMoves=possibleMoves.length;\r\n    moveIndex=random(numOfMoves);\r\n    if (numOfMoves!==0){\r\n        move=possibleMoves[moveIndex];\r\n    } else{\r\n        move=chooseRandomMoveInit(boardCopy)\r\n    }\r\n    individualMoves.push(move)\r\n    \r\n    \r\n    for(d=1;d<=depth-1;d++){\r\n        putDownPiece(move,turn,boardCopy)\r\n        possibleMoves=movesSearchGA(boardCopy);\r\n        // console.log(possibleMoves)\r\n        numOfMoves=possibleMoves.length;\r\n        moveIndex=random(numOfMoves);\r\n        move=possibleMoves[moveIndex];\r\n        individualMoves.push(move)\r\n    }\r\n    //    console.log(individualMoves)\r\n    return individualMoves\r\n\r\n}\r\n\r\nfunction uniformCrossover(momMoveComb,dadMoveComb){\r\n\r\n    let child1Moves=[];\r\n    let child2Moves=[];\r\n    let randomBit;\r\n    // console.log(\"mom.moveComb:\"+mom.moveComb)\r\n    // console.log(\"dad:\"+dad)\r\n    let momCopy=copyTwoDimArray(momMoveComb);\r\n    let dadCopy=copyTwoDimArray(dadMoveComb);\r\n    // console.log(mom.moveComb)\r\n    // console.log(dad.moveComb)\r\n    \r\n    for(var moveIndex=0;moveIndex<momCopy.length;moveIndex++){\r\n        randomBit=random(2);\r\n        if (randomBit===1){\r\n            child1Moves.push(momCopy[moveIndex])\r\n            child2Moves.push(dadCopy[moveIndex])\r\n        }\r\n        if (randomBit===0){\r\n            child1Moves.push(dadCopy[moveIndex])\r\n            child2Moves.push(momCopy[moveIndex])\r\n        }\r\n    }\r\n    return [child1Moves,child2Moves]\r\n}\r\n\r\n\r\nfunction mutate(moves,prop){\r\n    let randomNum;\r\n    let moveIndex;\r\n    let mutationChange=[-1,0,1]\r\n    let rowMuation,colMutation;\r\n    let moveMutated;\r\n    for (moveIndex=0;moveIndex<moves.length;moveIndex++){\r\n        randomNum=Math.random();\r\n        if (randomNum<prop){\r\n            rowMuation=mutationChange[random(3)]\r\n            colMutation=mutationChange[random(3)]\r\n            moveMutated=moves[moveIndex]\r\n            moves[moveIndex]=[moveMutated[0]+rowMuation,moveMutated[1]+colMutation]  \r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction sortPopulation(population){\r\n    \r\n    population.sort((ind1,ind2)=>ind2.score-ind1.score)\r\n\r\n}\r\n\r\n\r\nfunction pickTwoRandomIndex(len){\r\n    let array=[]\r\n    // console.log(\"len pick: \"+len)\r\n    for (var i=0;i<len;i++){\r\n        array.push(i)\r\n    }\r\n    // console.log(\"array: \"+array)\r\n    let index1=random(len)\r\n    array.splice(index1,1)\r\n    let index2=array[random(len-1)]\r\n    return [index1,index2]\r\n  }\r\n\r\n\r\n// function fitness(moveComb,pieceColor,defFactor,board){\r\n//     let index;\r\n//     let turn=pieceColor;\r\n//     let totalFitnessScore=0;\r\n//     let moveMade;\r\n//     let boardCopy=copyTwoDimArray(board);\r\n//     let indScore;\r\n//     // console.log(\"moveComb1: \"+moveComb)\r\n//     for(index=0;index<moveComb.length;index++){\r\n//         moveMade=moveComb[index];\r\n//         //discard illegal moveComb\r\n//         if( moveMade[0]<15 && moveMade[0]>=0 && moveMade[1]<15 && moveMade[1]>=0){\r\n//                 if(boardCopy[moveMade[0]][moveMade[1]] ===\" \"){\r\n//                     putDownPiece(moveMade,turn,boardCopy)\r\n//                     if(turn===pieceColor){\r\n//                         indScore=moveEvaluation(moveMade,turn,defFactor,boardCopy).score\r\n//                         // totalFitnessScore+=indScore/Math.pow(index+1,3)\r\n//                         totalFitnessScore+=indScore/(index+1)**3\r\n//                     } \r\n//                 } else {\r\n//                     return -10000;\r\n//                 }\r\n//         } else{\r\n//             return -10000;\r\n//         }\r\n//     }\r\n//     return totalFitnessScore\r\n// }\r\n\r\nfunction fitness(moveComb,pieceColor,defFactor,board){\r\n    let index;\r\n    let turn=pieceColor;\r\n    let totalFitnessScore=0;\r\n    let moveMade;\r\n    let boardCopy=copyTwoDimArray(board);\r\n    let indScore;\r\n    // console.log(\"moveComb1: \"+moveComb)\r\n    for(index=0;index<moveComb.length;index++){\r\n        moveMade=moveComb[index];\r\n        //discard illegal moveComb\r\n        if( moveMade[0]<15 && moveMade[0]>=0 && moveMade[1]<15 && moveMade[1]>=0){\r\n                if(boardCopy[moveMade[0]][moveMade[1]] ===\" \"){\r\n                    putDownPiece(moveMade,turn,boardCopy)\r\n                        indScore=moveEvaluation(moveMade,turn,defFactor,boardCopy).score\r\n                        // totalFitnessScore+=indScore/Math.pow(index+1,3)\r\n                        totalFitnessScore+=indScore/(index+1)**3\r\n                        turn=swapColor(turn)\r\n                } else {\r\n                    return -10000;\r\n                }\r\n        } else{\r\n            return -10000;\r\n        }\r\n    }\r\n    return totalFitnessScore\r\n}\r\n// function fitness(moveComb,pieceColor,defFactor,board){\r\n//     let index;\r\n//     let turn=pieceColor;\r\n//     let totalFitnessScore=0;\r\n//     let moveMade;\r\n//     let boardCopy=copyTwoDimArray(board);\r\n//     let indScore;\r\n\r\n//     // console.log(\"moveComb1: \"+moveComb)\r\n//     for(index=0;index<moveComb.length;index++){\r\n//         moveMade=moveComb[index];\r\n//         //discard illegal moveComb\r\n//         if( moveMade[0]<15 && moveMade[0]>=0 && moveMade[1]<15 && moveMade[1]>=0){\r\n//                 if(boardCopy[moveMade[0]][moveMade[1]] ===\" \"){\r\n//                     putDownPiece(moveMade,turn,boardCopy)\r\n//                     if(turn===pieceColor){\r\n//                         indScore=moveEvaluation(moveMade,turn,defFactor,boardCopy).score\r\n//                     }else {\r\n//                         indScore=-moveEvaluation(moveMade,turn,defFactor,boardCopy).score\r\n//                     }\r\n                    \r\n//                         // totalFitnessScore+=indScore/Math.pow(index+1,3)\r\n//                         totalFitnessScore+=indScore/(index+1)**3\r\n//                 } else {\r\n//                     return -10000;\r\n//                 }\r\n//         } else{\r\n//             return -10000;\r\n//         }\r\n//         turn=swapColor(turn)\r\n//     }\r\n//     console.log(totalFitnessScore)\r\n//     return totalFitnessScore\r\n// }\r\n\r\n\r\nfunction GAmove(depth,pieceColor,board){\r\n\r\n    // console.log(pieceColor)\r\n    let numOfPopulation=300;\r\n    let numOfIteration=100;\r\n    let numOfChildren=300;\r\nlet population=[]\r\nlet mutateProp=0.1\r\nlet defFactor=0.9;\r\nlet ind;\r\nlet itIndex;\r\nlet childIndex;\r\nlet bestInd;\r\n\r\nlet child1Score;\r\nlet child2Score;\r\nlet mom,momIndex;\r\nlet dad,dadIndex;\r\n\r\nlet child1,child2;\r\nlet child1MoveComb;\r\nlet child2MoveComb;\r\nlet moveComb;\r\nlet score;\r\n//initialise population\r\nfor (var i=0;i<numOfPopulation;i++){\r\n    moveComb=initIndMoves(pieceColor,depth,board)\r\n    // console.log(\"initial indivisual \"+i)\r\n    score=fitness(moveComb,pieceColor,defFactor,board)\r\n    ind=new individual(moveComb,score);\r\n    // console.log(\"score \"+ind.score)\r\n    population.push(ind)\r\n    // if (ind.score>=bestScore){\r\n    //     moveComb=ind.moveComb;\r\n    //     score=ind.score;\r\n    //     bestInd=new individual(moveComb,score);\r\n    // }\r\n    // console.log(\"bestInd moveComb: \"+bestInd.moveComb)\r\n}\r\n// console.log(population[0].moveComb)\r\n// console.log(\"forst ind in population: \"+population[0].moveComb)\r\n//iterations\r\nfor (itIndex=0;itIndex<=numOfIteration;itIndex++){\r\n    for (childIndex=0;childIndex<Math.floor(numOfChildren/2);childIndex++){\r\n        //choose random parents in the population\r\n        [momIndex,dadIndex]=pickTwoRandomIndex(population.length)\r\n        // console.log(\"momIndex: \"+momIndex)\r\n        // console.log(\"dadIndex: \"+dadIndex)\r\n        // console.log(\"population lenth: \"+population.length)\r\n        mom=population[momIndex];\r\n        dad=population[dadIndex];\r\n\r\n        //produce two childen\r\n        [child1MoveComb,child2MoveComb]=uniformCrossover(mom.moveComb,dad.moveComb)\r\n        //mutate two childen\r\n        mutate(child1MoveComb,mutateProp)\r\n        mutate(child2MoveComb,mutateProp)\r\n        //evaluate the child performance\r\n        child1Score=fitness(child1MoveComb,pieceColor,defFactor,board)\r\n        child2Score=fitness(child2MoveComb,pieceColor,defFactor,board)\r\n        child1=new individual(child1MoveComb,child1Score)\r\n        child2=new individual(child2MoveComb,child2Score)\r\n        //add the child to population\r\n        population.push(child1)\r\n        population.push(child2)\r\n        //sort population in descending order\r\n    }\r\n    sortPopulation(population)\r\n    population=population.slice(0, numOfPopulation-1)\r\n    \r\n}\r\n// for (let i=0;i<population.length;i++){\r\n//     console.log(\"population[i].score:\"+population[i].score)\r\n\r\n// }\r\nbestInd=population[0]\r\n// console.log(bestInd.moveComb)\r\nreturn bestInd.moveComb[0]\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nexport  default GAmove;","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\AILogic\\MoveEvaluation.jsx",["164"],[],"import {swapColor} from \"../../GameLogic.jsx\";\r\nimport {copyTwoDimArray} from \"../../GeneralLogic.jsx\"\r\nimport {moveObject} from \"./Objects\";\r\nfunction atkMoveEvaluation(move,pieceColor,board){\r\n    let rowCoord=move[0];\r\n    let colCoord=move[1];\r\n    let score=0;\r\n\r\n    let threeCount=0;\r\n    let fourCount=0;\r\n    let fourOneCount=0;\r\n    let fiveCount=0;\r\n    let vThreat=threatRecognise(verticalCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"vThreat: \"+vThreat)\r\n    let hThreat=threatRecognise(horizontalCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"hThreat: \"+hThreat)\r\n    let d1Threat=threatRecognise(leftBotToRightTopCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"d1Threat: \"+d1Threat)\r\n    let d2Threat=threatRecognise(leftTopToRightBotCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"d2Threat: \"+d2Threat)\r\n\r\n    let threats=[vThreat,hThreat,d1Threat,d2Threat];\r\n    // let threats=[hThreat];\r\n    let threatIndex;\r\n    let threat;\r\n    for (threatIndex=0;threatIndex<threats.length;threatIndex++){\r\n        threat=threats[threatIndex]\r\n        if (threat===2){\r\n            score+=2;\r\n        } else if(threat===21){\r\n            score +=1;\r\n        } else if(threat===31){\r\n            score+=4;\r\n        } else if(threat===3){\r\n            threeCount++;\r\n                if (threeCount===2 ){\r\n                    score+=22\r\n                } else if (threeCount>=3){\r\n                    score+=1;\r\n                } else {\r\n                    if(fourOneCount===1){\r\n                        score+=14\r\n                    } else{\r\n                        score+=8\r\n                    }                    \r\n                }             \r\n        } else if(threat===4){\r\n            fourCount++;\r\n            if (fourCount>=2 ){\r\n                score+=1\r\n            } else {\r\n                score+=32;\r\n            }\r\n        } else if(threat===41){\r\n            fourOneCount++;\r\n            if (fourOneCount===1){\r\n                if(threeCount===1){\r\n                    score+=22\r\n\r\n                }else{\r\n                    score+=16\r\n                }\r\n            } else{\r\n                score+=1\r\n            }\r\n    }   else if(threat===5){\r\n        fiveCount++;\r\n        if (fiveCount===1){\r\n            score+=128;\r\n        } else{\r\n            score+=1;\r\n        }\r\n    }\r\n}\r\n    // console.log(\"attack move evaluation:\"+score)\r\n    return {score:score, threats:threats}\r\n\r\n}\r\n\r\nfunction verticalCheck(rowCoord,colCoord,pieceColor,board){\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    let occupant;\r\n    let counts;\r\n    // console.log(\"rowIndex: \"+rowIndex)\r\n    // console.log(\"colIndex: \"+colIndex)\r\n    // console.log(\"board[rowIndex][colIndex]: \"+board[rowIndex][colIndex])\r\n    while( rowIndex>=0){\r\n        occupant=board[rowIndex][colIndex];\r\n        if (occupant!==\" \" ){\r\n            // console.log(\"check top rowIndex: \"+rowIndex)\r\n            // console.log(\"check top colIndex: \"+colIndex)\r\n            \r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            rowIndex--;\r\n        } else {\r\n            break;\r\n        };\r\n\r\n        }\r\n\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while(rowIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \"){\r\n            // console.log(\"check bot rowIndex: \"+rowIndex)\r\n            // console.log(\"check bot colIndex: \"+colIndex)\r\n            \r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            rowIndex++;\r\n\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    }\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    // console.log(\"vertical same counts: \"+counts.sameColor)\r\n    // console.log(\"vertical opposite counts: \"+counts.oppositeColor)\r\n    return counts\r\n}\r\n\r\n\r\nfunction horizontalCheck(rowCoord,colCoord,pieceColor,board){\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    // console.log(\"rowCoord: \"+rowCoord)\r\n    // console.log(\"colCoord: \"+colCoord)\r\n    // console.log(\"pieceColor: \"+pieceColor)\r\n    let occupant;\r\n    let counts;\r\n\r\n    while( colIndex>=0){\r\n        occupant=board[rowIndex][colIndex];\r\n        if (occupant!==\" \"){\r\n            \r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n                if(colIndex===0){\r\n                    oppositeColorCount++;\r\n                }\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n\r\n            colIndex--;\r\n        } else {\r\n            break;\r\n        }\r\n\r\n    };\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while(colIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \" ){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n                if(colIndex===14){\r\n                    oppositeColorCount++;\r\n                }\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            colIndex++;\r\n        } else {\r\n            break;\r\n        }\r\n\r\n    }\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    // console.log(\"horizontal same counts: \"+counts.sameColor)\r\n    // console.log(\"horizontal opposite counts: \"+counts.oppositeColor)\r\n    return counts\r\n}\r\n\r\n\r\nfunction leftBotToRightTopCheck (rowCoord,colCoord,pieceColor,board){\r\n\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    let occupant;\r\n    let counts;\r\n\r\n    //to right top\r\n        while(rowIndex>=0 && colIndex<15){\r\n            occupant=board[rowIndex][colIndex];\r\n            if(occupant!==\" \"){\r\n                \r\n                // console.log(\"rowIndex: \"+rowIndex) \r\n                // console.log(\"colIndex: \"+colIndex) \r\n                // console.log(\"occupant: \"+occupant) \r\n                if (occupant===pieceColor){\r\n                    sameColorCount++;   \r\n                    if(colIndex===15 || rowIndex===0){\r\n                        oppositeColorCount++;\r\n                    } \r\n                    // console.log(\"sameColorCount: \"+sameColorCount)        \r\n                } else {\r\n                    oppositeColorCount++;\r\n                    break;\r\n                }\r\n                rowIndex--;\r\n                colIndex++;\r\n            } else{\r\n                break;\r\n            }\r\n\r\n    }\r\n    //to left bot\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while( colIndex>=0 && rowIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if (occupant!==\" \"){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++;   \r\n                if(colIndex===0 || rowIndex===15){\r\n                    oppositeColorCount++;\r\n                }  \r\n                // console.log(count)        \r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            colIndex--;\r\n            rowIndex++;\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    } \r\n\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    return counts\r\n\r\n}\r\n\r\n\r\nfunction leftTopToRightBotCheck (rowCoord,colCoord,pieceColor,board){\r\n\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    let occupant;\r\n    let counts;\r\n    //to leftTop\r\n        while(rowIndex>=0 && colIndex>=0){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \" ){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++;   \r\n                if(colIndex===0 || rowIndex===0){\r\n                    oppositeColorCount++;\r\n                }  \r\n                // console.log(count)        \r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            rowIndex--;\r\n            colIndex--;\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    }\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while(colIndex<15 && rowIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \" ){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++;    \r\n                if(colIndex===15 || rowIndex===15){\r\n                    oppositeColorCount++;\r\n                } \r\n                // console.log(count)        \r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            colIndex++;\r\n            rowIndex++;\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    return counts\r\n}\r\n\r\nfunction threatRecognise(counts){\r\n    let sameColorCount= counts.sameColor;\r\n    let oppositeColorCount=counts.oppositeColor;\r\n    // console.log(\"threatRecognise sameColorCount: \"+sameColorCount)\r\n    // console.log(\"threatRecognise oppositeColorCount: \"+oppositeColorCount)\r\n    let threat=null;\r\n    if (sameColorCount===2 && oppositeColorCount===0){\r\n        threat=2\r\n    } else if (sameColorCount===2 && oppositeColorCount===1) {\r\n        threat=21\r\n    } else if (sameColorCount===2 && oppositeColorCount===1) {\r\n        threat=21\r\n    } else if (sameColorCount===3 && oppositeColorCount===0) {\r\n        threat=3\r\n    } else if (sameColorCount===3 && oppositeColorCount===1) {\r\n        threat=31\r\n    } else if (sameColorCount===4 && oppositeColorCount===0) {\r\n        threat=4\r\n    } else if (sameColorCount===4 && oppositeColorCount===1) {\r\n        threat=41\r\n    } else if ( sameColorCount>=5){\r\n    threat=5\r\n    }\r\n\r\nreturn threat\r\n}\r\n\r\nfunction moveEvaluation(move,pieceColor,defFactor,board){\r\n    let offence=atkMoveEvaluation(move,pieceColor,board);\r\n    let offenceScore=offence.score;\r\n    let atkThreats=offence.threats;\r\n    let oppositeColor=swapColor(pieceColor);\r\n    board[move[0]][move[1]]=oppositeColor;\r\n    let defence=atkMoveEvaluation(move,oppositeColor,board)\r\n    let defenceScore=defence.score*defFactor;\r\n    let defThreats=defence.threats;\r\n    board[move[0]][move[1]]=pieceColor;\r\n    let totalScore=offenceScore+defenceScore;\r\n    let moveEntity=new moveObject(move,atkThreats,defThreats,totalScore);\r\n    \r\n    // let totalScore=offenceScore;\r\n    // console.log(\"moveEvaluation function score:\"+totalScore)\r\n    return moveEntity\r\n}\r\n\r\n\r\n\r\nexport default moveEvaluation;","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\AILogic\\Objects.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\AILogic\\MoveSearch.jsx",["165"],[],"import moveEvaluation from \"./MoveEvaluationNew\";\r\nimport {chooseRandomMoveInit} from \"../RandomPlayer.jsx\";\r\nimport {moveObject} from \"./Objects\";\r\n\r\n\r\n\r\nfunction movesSearchMinimax(turn,defFactor,board,branchFactor){\r\n    let rowCoord;\r\n    let colCoord;\r\n    let movePriorities=[];\r\n    let moveNormals=[];\r\n    let moveCollection=[];\r\n    // let searchRange=[-1,1]\r\n    // let i,j\r\n    let rowIndex,colIndex;\r\n    let moveRow,moveCol;\r\n    let moveEntity;\r\n    let atkThreats;\r\n    let defThreats;\r\n    let moveValue;\r\n    let atkThreatIndex;\r\n    let defThreatsIndex;\r\n    let moveWithScore;\r\n    let loopNums;\r\n    let moveIndex;\r\n    let move;\r\n    //two for loop to scan every sqaure in the board.\r\n    for (rowCoord=0;rowCoord<15;rowCoord++){\r\n        for (colCoord=0;colCoord<15;colCoord++){\r\n            //check if the sqaure has stone\r\n            // console.log(\"rowCoord: \"+rowCoord)\r\n            // console.log(\"colCoord: \"+colCoord)\r\n            // console.log(\"board[rowCoord][colCoord]: \"+board[rowCoord][colCoord])\r\n            if (board[rowCoord][colCoord]!==\" \"){\r\n                // console.log(board[rowCoord][colCoord])\r\n                //search for neib sqaure\r\n                for (rowIndex=-2;rowIndex<=2;rowIndex++){\r\n                    for (colIndex=-2;colIndex<=2;colIndex++){\r\n                        // console.log(\"[rowIndex,colIndex]: \"+[rowIndex,colIndex])\r\n                      if (rowIndex !==0 || colIndex !==0){\r\n                        moveRow=rowCoord+rowIndex;\r\n                        moveCol=colCoord+colIndex;\r\n                        // console.log(\"[moveRow,moveCol]: \"+[moveRow,moveCol])\r\n                        //sqaure within the board range\r\n                        if (\r\n                            moveRow>=0 &&\r\n                            moveRow<=14 &&\r\n                            moveCol>=0 &&\r\n                            moveCol <=14 \r\n                        ){\r\n                            //if sqaure empty,make imaginary move to see its value.\r\n                            if(board[moveRow][moveCol]===\" \"){\r\n                                board[moveRow][moveCol]=turn;\r\n                                moveEntity=moveEvaluation([moveRow,moveCol],turn,defFactor,board)\r\n                                moveValue=moveEntity.score\r\n                                atkThreats=moveEntity.atkThreats;\r\n                                defThreats=moveEntity.defThreats;\r\n                                // console.log(\"moveEntity: \"+moveEntity.move)\r\n                                //check offence threats, if there is move to form five in-a-row threat, only consider such threat\r\n                                for(atkThreatIndex=0;atkThreatIndex<4;atkThreatIndex++){\r\n                                    if (atkThreats[atkThreatIndex]===5){\r\n                                        moveCollection=[moveEntity]\r\n                                        return moveCollection\r\n                                    }\r\n                                }\r\n                                //check offence threats, if there is move to prevent five in-a-row threat, only consider such threat\r\n                                for(defThreatsIndex=0;defThreatsIndex<4;defThreatsIndex++){\r\n                                    if (defThreats[defThreatsIndex]===5){\r\n                                        moveCollection=[moveEntity]\r\n                                        return moveCollection\r\n                                    }\r\n                                }\r\n                                \r\n                                //second priority moves\r\n                                if(moveValue>=29){\r\n\r\n                                    movePriorities.push(moveEntity)\r\n\r\n                                //third priority moves\r\n                                } else {\r\n                                    // console.log(\"moveWithScore.move: \"+moveWithScore.move)\r\n                                    // console.log(\"moveWithScore.score: \"+moveWithScore.score)\r\n                                    moveNormals.push(moveEntity)\r\n                                }\r\n                                //reverse the move to make the board unchanged\r\n                                board[moveRow][moveCol]=\" \";\r\n                            }\r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n            }\r\n        }\r\n    }\r\n    if (movePriorities.length!==0){\r\n        movePriorities.sort((move1,move2)=>move2.score-move1.score)\r\n        for (moveIndex=0;moveIndex<movePriorities.length;moveIndex++){\r\n            moveCollection.push(movePriorities[moveIndex])\r\n\r\n        }\r\n        return moveCollection\r\n        \r\n    } else if (moveNormals.length!==0){\r\n        moveNormals.sort((move1,move2)=>move2.score-move1.score)\r\n        // console.log(\"moveNormals: \"+moveNormals)\r\n        if(moveNormals.length<branchFactor){\r\n            loopNums=moveNormals.length\r\n        } else{\r\n            loopNums=branchFactor\r\n        }\r\n        for (moveIndex=0;moveIndex<loopNums;moveIndex++){\r\n            // console.log(\"move: \"+moveNormals[moveIndex].move)\r\n            // console.log(\"score: \"+moveNormals[moveIndex].score)\r\n            move=moveNormals[moveIndex]\r\n            moveCollection.push(move)\r\n        }\r\n        return moveCollection;\r\n    } \r\n    else {\r\n        move =chooseRandomMoveInit(board)\r\n        // console.log(\"init move: \"+move)\r\n        let emptyThreats=[null,null,null,null]\r\n        let randomMoveEntity=new moveObject(move,emptyThreats,emptyThreats,0)\r\n        moveCollection.push(randomMoveEntity)\r\n        return moveCollection\r\n    }\r\n\r\n   \r\n}\r\n\r\n\r\nfunction movesSearchGA(board){\r\n    let rowCoord;\r\n    let colCoord;\r\n    let moveCollection=[];\r\n    // let searchRange=[-1,1]\r\n    // let i,j\r\n    let rowIndex,colIndex;\r\n    let moveRow,moveCol;\r\n    // console.log(board)\r\n    for (rowCoord=0;rowCoord<15;rowCoord++){\r\n        for (colCoord=0;colCoord<15;colCoord++){\r\n            // console.log(\"rowCoord: \"+rowCoord)\r\n            // console.log(\"colCoord: \"+colCoord)\r\n            if (board[rowCoord][colCoord]!==\" \"){\r\n                // console.log(board[rowCoord][colCoord])\r\n                for (rowIndex=-1;rowIndex<=1;rowIndex++){\r\n                    for (colIndex=-1;colIndex<=1;colIndex++){\r\n                      if (rowIndex !==0 || colIndex !==0){\r\n                        moveRow=rowCoord+rowIndex;\r\n                        moveCol=colCoord+colIndex\r\n\r\n                        if (\r\n                            moveRow>=0 &&\r\n                            moveRow<=14 &&\r\n                            moveCol>=0 &&\r\n                            moveCol <=14 \r\n                        ){\r\n                            if(board[moveRow][moveCol]===\" \"){\r\n                                moveCollection.push([moveRow,moveCol]);\r\n                            }\r\n \r\n                        }\r\n                      }\r\n                    }\r\n                  }\r\n\r\n            }\r\n\r\n        }\r\n    }\r\n    return moveCollection;\r\n}\r\n\r\nexport {movesSearchMinimax,movesSearchGA};","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\ChoicePage\\AIVsAIChoice.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\ChoicePage\\PlayerVsAIChoice.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\ChoicePage\\SimulationChoice.jsx",["166"],[],"import React, { useState } from \"react\";\r\nimport { RadioButtons, NavButton } from \"../Buttons\";\r\nimport ComputerVsComputer from \"../gameplaypage/ComputerVsComputer\";\r\nimport Simulation from \"../gameplaypage/Simulation\";\r\nfunction SimulationChoice(props) {\r\n  let players = [\"Computer 1\", \"Computer 2\"];\r\n  let AIalgorithms = [\"Random\", \"Minimax\", \"MinimaxBad\", \"Genetic\",\"GeneticBad\"];\r\n  let defaultBlack = players[0];\r\n  let defaultAlgorithms = AIalgorithms[0];\r\n  const [gameSetting, changeSetting] = useState({\r\n    whoGoFirst: defaultBlack,\r\n    computer1: defaultAlgorithms,\r\n    computer2: defaultAlgorithms,\r\n  });\r\n\r\n  const [gameState, setState] = useState({\r\n    isStarted: false,\r\n  });\r\n\r\n//   console.log(gameSetting.whoGoFirst)\r\n// console.log(gameState.isStarted)\r\n  if (gameState.isStarted) {\r\n    return (\r\n        <Simulation onClickHome={()=>{\r\n             props.onClickHome();\r\n             \r\n        }}\r\n        settings={gameSetting}\r\n        />\r\n    )\r\n    \r\n  } else {\r\n    return (\r\n      <div>\r\n        <NavButton\r\n          text=\"Home\"\r\n          onClick={() => {\r\n            props.onClickHome();\r\n          }}\r\n        />\r\n\r\n{/* <RadioButtons \r\n        groupName=\"Who Plays First\" \r\n        values={players}\r\n        defaultValue={gameSetting.whoGoFirst} \r\n        changeSetting={(who)=>{\r\n            changeSetting({\r\n                whoGoFirst:who,\r\n                computer1:gameSetting.computer1,\r\n                computer2:gameSetting.computer2\r\n            })\r\n        }}\r\n        /> */}\r\n        <RadioButtons\r\n          groupName=\"Computer 1\"\r\n          values={AIalgorithms}\r\n          defaultValue={gameSetting.computer1}\r\n          changeSetting={(AI)=>{\r\n            changeSetting({\r\n                whoGoFirst:gameSetting.whoGoFirst,\r\n                computer1:AI,\r\n                computer2:gameSetting.computer2\r\n            })\r\n        }}\r\n        />\r\n            <RadioButtons\r\n          groupName=\"Computer 2\"\r\n          values={AIalgorithms}\r\n          defaultValue={gameSetting.computer2}\r\n          changeSetting={(AI)=>{\r\n            changeSetting({\r\n                whoGoFirst:gameSetting.whoGoFirst,\r\n                computer1:gameSetting.computer1,\r\n                computer2:AI,\r\n            })\r\n        }}\r\n        />\r\n        \r\n        <NavButton\r\n          text=\"Next\"\r\n          onClick={() => {\r\n            setState({\r\n              isStarted: true,\r\n            });\r\n          }}\r\n          \r\n        />\r\n      </div>\r\n    );\r\n  }\r\n}\r\n\r\nexport default SimulationChoice;\r\n","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\AIplayers\\AILogic\\MoveEvaluationNew.jsx",["167","168","169","170","171"],[],"import {swapColor} from \"../../GameLogic.jsx\";\r\nimport {copyTwoDimArray} from \"../../GeneralLogic.jsx\"\r\nimport {moveObject} from \"./Objects\";\r\nfunction atkMoveEvaluation(move,pieceColor,board){\r\n    let rowCoord=move[0];\r\n    let colCoord=move[1];\r\n    let score=0;\r\n\r\n    let threeCount=0;\r\n    let fourCount=0;\r\n    let fourOneCount=0;\r\n    let fiveCount=0;\r\n    let vThreat=threatRecognise(verticalCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"vThreat: \"+vThreat)\r\n    let hThreat=threatRecognise(horizontalCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"hThreat: \"+hThreat)\r\n    let d1Threat=threatRecognise(leftBotToRightTopCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"d1Threat: \"+d1Threat)\r\n    let d2Threat=threatRecognise(leftTopToRightBotCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"d2Threat: \"+d2Threat)\r\n\r\n    let threats=[vThreat,hThreat,d1Threat,d2Threat];\r\n    // let threats=[hThreat];\r\n    let threatIndex;\r\n    let threat;\r\n    for (threatIndex=0;threatIndex<threats.length;threatIndex++){\r\n        threat=threats[threatIndex]\r\n        if (threat===2){\r\n            score+=2;\r\n        } else if(threat===21){\r\n            score +=1;\r\n        } else if(threat===31){\r\n            score+=4;\r\n        } else if(threat===3){\r\n                score+=9            \r\n        } else if(threat===4){\r\n            score+=37\r\n        } else if(threat===41){\r\n            score+=20\r\n    }   else if(threat===5){\r\n        score+=150\r\n    }\r\n}\r\n    // console.log(\"attack move evaluation:\"+score)\r\n    return {score:score, threats:threats}\r\n\r\n}\r\n\r\nfunction verticalCheck(rowCoord,colCoord,pieceColor,board){\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    let occupant;\r\n    let counts;\r\n    // console.log(\"rowIndex: \"+rowIndex)\r\n    // console.log(\"colIndex: \"+colIndex)\r\n    // console.log(\"board[rowIndex][colIndex]: \"+board[rowIndex][colIndex])\r\n    while( rowIndex>=0){\r\n        occupant=board[rowIndex][colIndex];\r\n        if (occupant!==\" \" ){\r\n            // console.log(\"check top rowIndex: \"+rowIndex)\r\n            // console.log(\"check top colIndex: \"+colIndex)\r\n            \r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            rowIndex--;\r\n        } else {\r\n            break;\r\n        };\r\n\r\n        }\r\n\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while(rowIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \"){\r\n            // console.log(\"check bot rowIndex: \"+rowIndex)\r\n            // console.log(\"check bot colIndex: \"+colIndex)\r\n            \r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            rowIndex++;\r\n\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    }\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    // console.log(\"vertical same counts: \"+counts.sameColor)\r\n    // console.log(\"vertical opposite counts: \"+counts.oppositeColor)\r\n    return counts\r\n}\r\n\r\n\r\nfunction horizontalCheck(rowCoord,colCoord,pieceColor,board){\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    // console.log(\"rowCoord: \"+rowCoord)\r\n    // console.log(\"colCoord: \"+colCoord)\r\n    // console.log(\"pieceColor: \"+pieceColor)\r\n    let occupant;\r\n    let counts;\r\n\r\n    while( colIndex>=0){\r\n        occupant=board[rowIndex][colIndex];\r\n        if (occupant!==\" \"){\r\n            \r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n                if(colIndex===0){\r\n                    oppositeColorCount++;\r\n                }\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n\r\n            colIndex--;\r\n        } else {\r\n            break;\r\n        }\r\n\r\n    };\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while(colIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \" ){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n                if(colIndex===14){\r\n                    oppositeColorCount++;\r\n                }\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            colIndex++;\r\n        } else {\r\n            break;\r\n        }\r\n\r\n    }\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    // console.log(\"horizontal same counts: \"+counts.sameColor)\r\n    // console.log(\"horizontal opposite counts: \"+counts.oppositeColor)\r\n    return counts\r\n}\r\n\r\n\r\nfunction leftBotToRightTopCheck (rowCoord,colCoord,pieceColor,board){\r\n\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    let occupant;\r\n    let counts;\r\n\r\n    //to right top\r\n        while(rowIndex>=0 && colIndex<15){\r\n            occupant=board[rowIndex][colIndex];\r\n            if(occupant!==\" \"){\r\n                \r\n                // console.log(\"rowIndex: \"+rowIndex) \r\n                // console.log(\"colIndex: \"+colIndex) \r\n                // console.log(\"occupant: \"+occupant) \r\n                if (occupant===pieceColor){\r\n                    sameColorCount++;   \r\n                    if(colIndex===15 || rowIndex===0){\r\n                        oppositeColorCount++;\r\n                    } \r\n                    // console.log(\"sameColorCount: \"+sameColorCount)        \r\n                } else {\r\n                    oppositeColorCount++;\r\n                    break;\r\n                }\r\n                rowIndex--;\r\n                colIndex++;\r\n            } else{\r\n                break;\r\n            }\r\n\r\n    }\r\n    //to left bot\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while( colIndex>=0 && rowIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if (occupant!==\" \"){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++;   \r\n                if(colIndex===0 || rowIndex===15){\r\n                    oppositeColorCount++;\r\n                }  \r\n                // console.log(count)        \r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            colIndex--;\r\n            rowIndex++;\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    } \r\n\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    return counts\r\n\r\n}\r\n\r\n\r\nfunction leftTopToRightBotCheck (rowCoord,colCoord,pieceColor,board){\r\n\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    let occupant;\r\n    let counts;\r\n    //to leftTop\r\n        while(rowIndex>=0 && colIndex>=0){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \" ){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++;   \r\n                if(colIndex===0 || rowIndex===0){\r\n                    oppositeColorCount++;\r\n                }  \r\n                // console.log(count)        \r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            rowIndex--;\r\n            colIndex--;\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    }\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while(colIndex<15 && rowIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \" ){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++;    \r\n                if(colIndex===15 || rowIndex===15){\r\n                    oppositeColorCount++;\r\n                } \r\n                // console.log(count)        \r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            colIndex++;\r\n            rowIndex++;\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    return counts\r\n}\r\n\r\nfunction threatRecognise(counts){\r\n    let sameColorCount= counts.sameColor;\r\n    let oppositeColorCount=counts.oppositeColor;\r\n    // console.log(\"threatRecognise sameColorCount: \"+sameColorCount)\r\n    // console.log(\"threatRecognise oppositeColorCount: \"+oppositeColorCount)\r\n    let threat=null;\r\n    if (sameColorCount===2 && oppositeColorCount===0){\r\n        threat=2\r\n    } else if (sameColorCount===2 && oppositeColorCount===1) {\r\n        threat=21\r\n    } else if (sameColorCount===2 && oppositeColorCount===1) {\r\n        threat=21\r\n    } else if (sameColorCount===3 && oppositeColorCount===0) {\r\n        threat=3\r\n    } else if (sameColorCount===3 && oppositeColorCount===1) {\r\n        threat=31\r\n    } else if (sameColorCount===4 && oppositeColorCount===0) {\r\n        threat=4\r\n    } else if (sameColorCount===4 && oppositeColorCount===1) {\r\n        threat=41\r\n    } else if ( sameColorCount>=5){\r\n    threat=5\r\n    }\r\n\r\nreturn threat\r\n}\r\n\r\nfunction moveEvaluation(move,pieceColor,defFactor,board){\r\n    let offence=atkMoveEvaluation(move,pieceColor,board);\r\n    let offenceScore=offence.score;\r\n    let atkThreats=offence.threats;\r\n    let oppositeColor=swapColor(pieceColor);\r\n    board[move[0]][move[1]]=oppositeColor;\r\n    let defence=atkMoveEvaluation(move,oppositeColor,board)\r\n    let defenceScore=defence.score*defFactor;\r\n    let defThreats=defence.threats;\r\n    board[move[0]][move[1]]=pieceColor;\r\n    let totalScore=offenceScore+defenceScore;\r\n    let moveEntity=new moveObject(move,atkThreats,defThreats,totalScore);\r\n    \r\n    // let totalScore=offenceScore;\r\n    // console.log(\"moveEvaluation function score:\"+totalScore)\r\n    return moveEntity\r\n}\r\n\r\n\r\n\r\nexport default moveEvaluation;","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\components\\GeneralLogic.jsx",[],[],"C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\Testing\\minimax.jsx",["172"],[],"import moveEvaluation from \"../components/AIplayers/AILogic/MoveEvaluationNew\";\r\nimport { avalibleMoves } from \"../components/GameLogic\";\r\nimport { swapColor } from \"../components/GameLogic\";\r\nimport { copyTwoDimArray } from \"../components/GeneralLogic\";\r\nimport { putDownPiece } from \"../components/GameLogic\";\r\nimport { movesSearchMinimax } from \"../components/AIplayers/AILogic/MoveSearch\";\r\nimport moveEvaluationNoDF from \"./moveEvaluationNoDF\";\r\n\r\n\r\nfunction minimaxNR(turn,depthAwayFromRoot,depthAwayFromLeaf,board,bestScore1=-100000){\r\n    depthAwayFromLeaf-=1;\r\n    // console.log(\"depthAwayFromLeaf: \"+depthAwayFromLeaf)\r\n    let defFactor=0.9;\r\n    let opponentColor=swapColor(turn)\r\n    let avalibleMoves1= avalibleMoves(board)\r\n    // console.log(avalibleMoves1)\r\n    let moveIndex1;\r\n    let moveMade1;\r\n    let B1Score;\r\n    let bestScore2;\r\n    let bestMove;\r\n    let B1;\r\n    for (moveIndex1=0;moveIndex1<avalibleMoves1.length;moveIndex1++){\r\n        B1=copyTwoDimArray(board)\r\n        moveMade1=avalibleMoves1[moveIndex1]\r\n\r\n        putDownPiece(moveMade1,turn,B1)\r\n        bestScore2=-bestScore1;\r\n\r\n        if(depthAwayFromLeaf===0){\r\n            if((depthAwayFromRoot+1)%2===1){\r\n                B1Score=moveEvaluation(moveMade1,turn,defFactor,B1).score   \r\n            } else{\r\n                B1Score=-moveEvaluation(moveMade1,turn,defFactor,B1).score  \r\n            }\r\n            \r\n        } else {\r\n            depthAwayFromRoot+=1\r\n            B1Score=minimaxNR(opponentColor,depthAwayFromRoot,depthAwayFromLeaf,B1,bestScore2)\r\n            depthAwayFromRoot-=1\r\n        }\r\n        if((depthAwayFromRoot+1)%2===1){\r\n            if(B1Score>=bestScore1){\r\n                bestScore1=B1Score;\r\n                bestMove=moveMade1;\r\n            }\r\n        } else {\r\n            if(B1Score<=bestScore1){\r\n                bestScore1=B1Score\r\n                bestMove=moveMade1;\r\n            }\r\n        }\r\n    }\r\n\r\n    if(depthAwayFromRoot !== 0  ){\r\n\r\n        return bestScore1;\r\n\r\n    } else {\r\n// console.log(\"bestMove: \"+bestMove)\r\n        return bestMove;\r\n    }\r\n    \r\n}\r\n\r\nfunction minimaxNoReductionNoDF(turn,depthAwayFromRoot,depthAwayFromLeaf,board,bestScore1=-100000){\r\n    depthAwayFromLeaf-=1;\r\n    // console.log(\"depthAwayFromLeaf: \"+depthAwayFromLeaf)\r\n    let defFactor=0.9;\r\n    let opponentColor=swapColor(turn)\r\n    let avalibleMoves1= avalibleMoves(board)\r\n    // console.log(avalibleMoves1)\r\n    let moveIndex1;\r\n    let moveMade1;\r\n    let B1Score;\r\n    let bestScore2;\r\n    let bestMove;\r\n    let B1;\r\n    for (moveIndex1=0;moveIndex1<avalibleMoves1.length;moveIndex1++){\r\n        B1=copyTwoDimArray(board)\r\n        moveMade1=avalibleMoves1[moveIndex1]\r\n\r\n        putDownPiece(moveMade1,turn,B1)\r\n        bestScore2=-bestScore1;\r\n\r\n        if(depthAwayFromLeaf===0){\r\n            if((depthAwayFromRoot+1)%2===1){\r\n                B1Score=moveEvaluation(moveMade1,turn,defFactor,B1).score   \r\n            } else{\r\n                B1Score=-moveEvaluation(moveMade1,turn,defFactor,B1).score  \r\n            }\r\n            \r\n        } else {\r\n            depthAwayFromRoot+=1\r\n            B1Score=minimaxNoReductionNoDF(opponentColor,depthAwayFromRoot,depthAwayFromLeaf,B1,bestScore2)\r\n            depthAwayFromRoot-=1\r\n        }\r\n        if((depthAwayFromRoot+1)%2===1){\r\n            if(B1Score>=bestScore1){\r\n                bestScore1=B1Score;\r\n                bestMove=moveMade1;\r\n            }\r\n        } else {\r\n            if(B1Score<=bestScore1){\r\n                bestScore1=B1Score\r\n                bestMove=moveMade1;\r\n            }\r\n        }\r\n    }\r\n\r\n    if(depthAwayFromRoot !== 0  ){\r\n\r\n        return bestScore1;\r\n\r\n    } else {\r\n// console.log(\"bestMove: \"+bestMove)\r\n        return bestMove;\r\n    }\r\n    \r\n}\r\n\r\n\r\nfunction minimaxMoveLimit(turn,depthAwayFromRoot,depthAwayFromLeaf,board,bestScore1=-100000,alphaBetaScore=100000){\r\n    depthAwayFromLeaf-=1;\r\n    let defFactor=0.9;\r\n    let branchFactor=10;\r\n    let opponentColor=swapColor(turn)\r\n    let avalibleMoves1= movesSearchMinimax(turn,defFactor,board,branchFactor)\r\n    let moveIndex1;\r\n    let moveMade1;\r\n    let B1Score;\r\n    let bestScore2;\r\n    let bestMove;\r\n    let B1;\r\n    for (moveIndex1=0;moveIndex1<avalibleMoves1.length;moveIndex1++){\r\n        B1=copyTwoDimArray(board)\r\n        moveMade1=avalibleMoves1[moveIndex1].move\r\n        // console.log(\"moveMade1: \"+moveMade1)\r\n        putDownPiece(moveMade1,turn,B1)\r\n        //alphabeta score is the default score for \r\n\r\n        //bestScore1 is the default score of current parent node\r\n\r\n        //bestScore2 is the default score of parent node for next branching out\r\n        bestScore2=-bestScore1;\r\n\r\n        if(depthAwayFromLeaf===0){\r\n            if((depthAwayFromRoot+1)%2===1){\r\n                B1Score=moveEvaluation(moveMade1,turn,defFactor,B1).score   \r\n            } else{\r\n                B1Score=-moveEvaluation(moveMade1,turn,defFactor,B1).score  \r\n            }\r\n            // console.log(\"B1Score: \"+B1Score)\r\n        } else {\r\n            depthAwayFromRoot+=1\r\n            B1Score=minimaxMoveLimit(opponentColor,depthAwayFromRoot,depthAwayFromLeaf,B1,bestScore2,bestScore1)\r\n            depthAwayFromRoot-=1\r\n        }\r\n        //odd depth maximiser\r\n        if((depthAwayFromRoot+1)%2===1){\r\n            if(B1Score>=bestScore1){\r\n                bestScore1=B1Score;\r\n                bestMove=moveMade1;\r\n\r\n            }\r\n        // even depth minimiser\r\n        } else {\r\n            if(B1Score<=bestScore1){\r\n                bestScore1=B1Score\r\n                bestMove=moveMade1;\r\n \r\n            }\r\n        }\r\n    }\r\n    //return the score back to the parent node if it is not in the root node\r\n    if(depthAwayFromRoot !== 0  ){\r\n\r\n        return bestScore1;\r\n    //if already in the first depth, return the move.\r\n    } else {\r\n\r\n        return bestMove;\r\n    }\r\n    \r\n}\r\n\r\n\r\nfunction minimaxAB(turn,depthAwayFromRoot,depthAwayFromLeaf,board,bestScore1=-100000,alphaBetaScore=100000){\r\n    depthAwayFromLeaf-=1;\r\n    // console.log(\"depthAwayFromLeaf: \"+depthAwayFromLeaf)\r\n    let defFactor=0.9;\r\n    let branchFactor=10;\r\n    let opponentColor=swapColor(turn)\r\n    let avalibleMoves1= movesSearchMinimax(turn,defFactor,board,branchFactor)\r\n    let moveIndex1;\r\n    let moveMade1;\r\n    let B1Score;\r\n    let bestScore2;\r\n    let bestMove;\r\n    let B1;\r\n \r\n    \r\n    //first depth, consider different computer moves\r\n    for (moveIndex1=0;moveIndex1<avalibleMoves1.length;moveIndex1++){\r\n        B1=copyTwoDimArray(board)\r\n        moveMade1=avalibleMoves1[moveIndex1].move\r\n        // console.log(\"moveMade1: \"+moveMade1)\r\n        putDownPiece(moveMade1,turn,B1)\r\n        //alphabeta score is the default score for \r\n\r\n        //bestScore1 is the default score of current parent node\r\n\r\n        //bestScore2 is the default score of parent node for next branching out\r\n        bestScore2=-bestScore1;\r\n\r\n        if(depthAwayFromLeaf===0){\r\n            if((depthAwayFromRoot+1)%2===1){\r\n                B1Score=moveEvaluation(moveMade1,turn,defFactor,B1).score   \r\n            } else{\r\n                B1Score=-moveEvaluation(moveMade1,turn,defFactor,B1).score  \r\n            }\r\n            // console.log(\"B1Score: \"+B1Score)\r\n            \r\n        } else {\r\n            depthAwayFromRoot+=1\r\n            B1Score=minimaxAB(opponentColor,depthAwayFromRoot,depthAwayFromLeaf,B1,bestScore2,bestScore1)\r\n            depthAwayFromRoot-=1\r\n        }\r\n        //odd depth maximiser\r\n        if((depthAwayFromRoot+1)%2===1){\r\n            if(B1Score>=bestScore1){\r\n                bestScore1=B1Score;\r\n                bestMove=moveMade1;\r\n                if(B1Score>=alphaBetaScore){\r\n                    break;\r\n                }\r\n            }\r\n        // even depth minimiser\r\n        } else {\r\n            if(B1Score<=bestScore1){\r\n                bestScore1=B1Score\r\n                bestMove=moveMade1;\r\n                if(B1Score<=alphaBetaScore){\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    //return the score back to the parent node if it is not in the root node\r\n    if(depthAwayFromRoot !== 0  ){\r\n        // console.log(\"------------------------\")\r\n        // console.log(\"depthAwayFromRoot: \"+depthAwayFromRoot)\r\n        // console.log(\"bestScore1: \"+bestScore1)\r\n        return bestScore1;\r\n    //if already in the first depth, return the move.\r\n    } else {\r\n        // console.log(\"------------------------\")\r\n        // console.log(\"depthAwayFromRoot: \"+depthAwayFromRoot)\r\n        // console.log(\"bestMove: \"+bestMove)\r\n        return bestMove;\r\n    }\r\n    \r\n}\r\n\r\n\r\nexport {minimaxNR,minimaxNoReductionNoDF,minimaxMoveLimit,minimaxAB};","C:\\Users\\Jason\\Desktop\\hxz157\\gomoku\\src\\Testing\\moveEvaluationNoDF.jsx",["173","174","175","176","177"],[],"import {swapColor} from \"../components/GameLogic.jsx\";\r\nimport { copyTwoDimArray } from \"../components/GeneralLogic.jsx\";\r\nimport { moveObject } from \"../components/AIplayers/AILogic/Objects.jsx\";\r\nfunction atkMoveEvaluation(move,pieceColor,board){\r\n    let rowCoord=move[0];\r\n    let colCoord=move[1];\r\n    let score=0;\r\n    let threeCount=0;\r\n    let fourCount=0;\r\n    let fourOneCount=0;\r\n    let fiveCount=0;\r\n    let vThreat=threatRecognise(verticalCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"vThreat: \"+vThreat)\r\n    let hThreat=threatRecognise(horizontalCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"hThreat: \"+hThreat)\r\n    let d1Threat=threatRecognise(leftBotToRightTopCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"d1Threat: \"+d1Threat)\r\n    let d2Threat=threatRecognise(leftTopToRightBotCheck(rowCoord,colCoord,pieceColor,board));\r\n    // console.log(\"d2Threat: \"+d2Threat)\r\n\r\n    let threats=[vThreat,hThreat,d1Threat,d2Threat];\r\n    // let threats=[hThreat];\r\n    let threatIndex;\r\n    let threat;\r\n    for (threatIndex=0;threatIndex<threats.length;threatIndex++){\r\n        threat=threats[threatIndex]\r\n        if (threat===2){\r\n            score+=2;\r\n        } else if(threat===21){\r\n            score +=1;\r\n        } else if(threat===31){\r\n            score+=4;\r\n        } else if(threat===3){\r\n                score+=9            \r\n        } else if(threat===4){\r\n            score+=37\r\n        } else if(threat===41){\r\n            score+=20\r\n    }   else if(threat===5){\r\n        score+=150\r\n    }\r\n}\r\n    // console.log(\"attack move evaluation:\"+score)\r\n    return {score:score, threats:threats}\r\n\r\n}\r\n\r\nfunction verticalCheck(rowCoord,colCoord,pieceColor,board){\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    let occupant;\r\n    let counts;\r\n    // console.log(\"rowIndex: \"+rowIndex)\r\n    // console.log(\"colIndex: \"+colIndex)\r\n    // console.log(\"board[rowIndex][colIndex]: \"+board[rowIndex][colIndex])\r\n    while( rowIndex>=0){\r\n        occupant=board[rowIndex][colIndex];\r\n        if (occupant!==\" \" ){\r\n            // console.log(\"check top rowIndex: \"+rowIndex)\r\n            // console.log(\"check top colIndex: \"+colIndex)\r\n            \r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            rowIndex--;\r\n        } else {\r\n            break;\r\n        };\r\n\r\n        }\r\n\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while(rowIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \"){\r\n            // console.log(\"check bot rowIndex: \"+rowIndex)\r\n            // console.log(\"check bot colIndex: \"+colIndex)\r\n            \r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            rowIndex++;\r\n\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    }\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    // console.log(\"vertical same counts: \"+counts.sameColor)\r\n    // console.log(\"vertical opposite counts: \"+counts.oppositeColor)\r\n    return counts\r\n}\r\n\r\n\r\nfunction horizontalCheck(rowCoord,colCoord,pieceColor,board){\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    // console.log(\"rowCoord: \"+rowCoord)\r\n    // console.log(\"colCoord: \"+colCoord)\r\n    // console.log(\"pieceColor: \"+pieceColor)\r\n    let occupant;\r\n    let counts;\r\n\r\n    while( colIndex>=0){\r\n        occupant=board[rowIndex][colIndex];\r\n        if (occupant!==\" \"){\r\n            \r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n                if(colIndex===0){\r\n                    oppositeColorCount++;\r\n                }\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n\r\n            colIndex--;\r\n        } else {\r\n            break;\r\n        }\r\n\r\n    };\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while(colIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \" ){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++\r\n                if(colIndex===14){\r\n                    oppositeColorCount++;\r\n                }\r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            colIndex++;\r\n        } else {\r\n            break;\r\n        }\r\n\r\n    }\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    // console.log(\"horizontal same counts: \"+counts.sameColor)\r\n    // console.log(\"horizontal opposite counts: \"+counts.oppositeColor)\r\n    return counts\r\n}\r\n\r\n\r\nfunction leftBotToRightTopCheck (rowCoord,colCoord,pieceColor,board){\r\n\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    let occupant;\r\n    let counts;\r\n\r\n    //to right top\r\n        while(rowIndex>=0 && colIndex<15){\r\n            occupant=board[rowIndex][colIndex];\r\n            if(occupant!==\" \"){\r\n                \r\n                // console.log(\"rowIndex: \"+rowIndex) \r\n                // console.log(\"colIndex: \"+colIndex) \r\n                // console.log(\"occupant: \"+occupant) \r\n                if (occupant===pieceColor){\r\n                    sameColorCount++;   \r\n                    if(colIndex===15 || rowIndex===0){\r\n                        oppositeColorCount++;\r\n                    } \r\n                    // console.log(\"sameColorCount: \"+sameColorCount)        \r\n                } else {\r\n                    oppositeColorCount++;\r\n                    break;\r\n                }\r\n                rowIndex--;\r\n                colIndex++;\r\n            } else{\r\n                break;\r\n            }\r\n\r\n    }\r\n    //to left bot\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while( colIndex>=0 && rowIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if (occupant!==\" \"){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++;   \r\n                if(colIndex===0 || rowIndex===15){\r\n                    oppositeColorCount++;\r\n                }  \r\n                // console.log(count)        \r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            colIndex--;\r\n            rowIndex++;\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    } \r\n\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    return counts\r\n\r\n}\r\n\r\n\r\nfunction leftTopToRightBotCheck (rowCoord,colCoord,pieceColor,board){\r\n\r\n    let sameColorCount=-1;\r\n    let oppositeColorCount=0;\r\n    let rowIndex=rowCoord;\r\n    let colIndex=colCoord;\r\n    let occupant;\r\n    let counts;\r\n    //to leftTop\r\n        while(rowIndex>=0 && colIndex>=0){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \" ){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++;   \r\n                if(colIndex===0 || rowIndex===0){\r\n                    oppositeColorCount++;\r\n                }  \r\n                // console.log(count)        \r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            rowIndex--;\r\n            colIndex--;\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    }\r\n    rowIndex=rowCoord;\r\n    colIndex=colCoord;\r\n    while(colIndex<15 && rowIndex<15){\r\n        occupant=board[rowIndex][colIndex];\r\n        if(occupant!==\" \" ){\r\n            if (occupant===pieceColor){\r\n                sameColorCount++;    \r\n                if(colIndex===15 || rowIndex===15){\r\n                    oppositeColorCount++;\r\n                } \r\n                // console.log(count)        \r\n            } else {\r\n                oppositeColorCount++;\r\n                break;\r\n            }\r\n            colIndex++;\r\n            rowIndex++;\r\n        } else{\r\n            break;\r\n        }\r\n\r\n    }\r\n\r\n    counts={sameColor:sameColorCount, oppositeColor:oppositeColorCount}\r\n    return counts\r\n}\r\n\r\nfunction threatRecognise(counts){\r\n    let sameColorCount= counts.sameColor;\r\n    let oppositeColorCount=counts.oppositeColor;\r\n    // console.log(\"threatRecognise sameColorCount: \"+sameColorCount)\r\n    // console.log(\"threatRecognise oppositeColorCount: \"+oppositeColorCount)\r\n    let threat=null;\r\n    if (sameColorCount===2 && oppositeColorCount===0){\r\n        threat=2\r\n    } else if (sameColorCount===2 && oppositeColorCount===1) {\r\n        threat=21\r\n    } else if (sameColorCount===2 && oppositeColorCount===1) {\r\n        threat=21\r\n    } else if (sameColorCount===3 && oppositeColorCount===0) {\r\n        threat=3\r\n    } else if (sameColorCount===3 && oppositeColorCount===1) {\r\n        threat=31\r\n    } else if (sameColorCount===4 && oppositeColorCount===0) {\r\n        threat=4\r\n    } else if (sameColorCount===4 && oppositeColorCount===1) {\r\n        threat=41\r\n    } else if ( sameColorCount>=5){\r\n    threat=5\r\n    }\r\n\r\nreturn threat\r\n}\r\n\r\nfunction moveEvaluationNoDF(move,pieceColor,board){\r\n    let offence=atkMoveEvaluation(move,pieceColor,board);\r\n    let offenceScore=offence.score;\r\n    let atkThreats=offence.threats;\r\n    let oppositeColor=swapColor(pieceColor);\r\n    board[move[0]][move[1]]=oppositeColor;\r\n    let defence=atkMoveEvaluation(move,oppositeColor,board)\r\n    let defenceScore=defence.score;\r\n    let defThreats=defence.threats;\r\n    board[move[0]][move[1]]=pieceColor;\r\n    let totalScore=offenceScore+defenceScore;\r\n    let moveEntity=new moveObject(move,atkThreats,defThreats,totalScore);\r\n    \r\n    // let totalScore=offenceScore;\r\n    // console.log(\"moveEvaluation function score:\"+totalScore)\r\n    return moveEntity\r\n}\r\n\r\n\r\n\r\nexport default moveEvaluationNoDF;",{"ruleId":"178","severity":1,"message":"179","line":3,"column":8,"nodeType":"180","messageId":"181","endLine":3,"endColumn":13},{"ruleId":"178","severity":1,"message":"182","line":4,"column":9,"nodeType":"180","messageId":"181","endLine":4,"endColumn":21},{"ruleId":"178","severity":1,"message":"183","line":4,"column":22,"nodeType":"180","messageId":"181","endLine":4,"endColumn":34},{"ruleId":"178","severity":1,"message":"184","line":1,"column":17,"nodeType":"180","messageId":"181","endLine":1,"endColumn":25},{"ruleId":"178","severity":1,"message":"185","line":7,"column":8,"nodeType":"180","messageId":"181","endLine":7,"endColumn":22},{"ruleId":"178","severity":1,"message":"186","line":2,"column":17,"nodeType":"180","messageId":"181","endLine":2,"endColumn":26},{"ruleId":"187","severity":1,"message":"188","line":65,"column":1,"nodeType":"189","messageId":"190","endLine":79,"endColumn":11},{"ruleId":"178","severity":1,"message":"191","line":11,"column":9,"nodeType":"180","messageId":"181","endLine":11,"endColumn":27},{"ruleId":"178","severity":1,"message":"192","line":11,"column":28,"nodeType":"180","messageId":"181","endLine":11,"endColumn":42},{"ruleId":"178","severity":1,"message":"191","line":10,"column":9,"nodeType":"180","messageId":"181","endLine":10,"endColumn":27},{"ruleId":"178","severity":1,"message":"192","line":10,"column":28,"nodeType":"180","messageId":"181","endLine":10,"endColumn":42},{"ruleId":"178","severity":1,"message":"185","line":12,"column":8,"nodeType":"180","messageId":"181","endLine":12,"endColumn":22},{"ruleId":"178","severity":1,"message":"179","line":3,"column":8,"nodeType":"180","messageId":"181","endLine":3,"endColumn":13},{"ruleId":"178","severity":1,"message":"193","line":4,"column":9,"nodeType":"180","messageId":"181","endLine":4,"endColumn":18},{"ruleId":"178","severity":1,"message":"194","line":4,"column":19,"nodeType":"180","messageId":"181","endLine":4,"endColumn":33},{"ruleId":"178","severity":1,"message":"195","line":5,"column":9,"nodeType":"180","messageId":"181","endLine":5,"endColumn":25},{"ruleId":"178","severity":1,"message":"184","line":7,"column":10,"nodeType":"180","messageId":"181","endLine":7,"endColumn":18},{"ruleId":"178","severity":1,"message":"196","line":8,"column":8,"nodeType":"180","messageId":"181","endLine":8,"endColumn":16},{"ruleId":"178","severity":1,"message":"197","line":12,"column":9,"nodeType":"180","messageId":"181","endLine":12,"endColumn":18},{"ruleId":"178","severity":1,"message":"198","line":12,"column":19,"nodeType":"180","messageId":"181","endLine":12,"endColumn":41},{"ruleId":"178","severity":1,"message":"199","line":12,"column":42,"nodeType":"180","messageId":"181","endLine":12,"endColumn":58},{"ruleId":"178","severity":1,"message":"200","line":12,"column":59,"nodeType":"180","messageId":"181","endLine":12,"endColumn":68},{"ruleId":"178","severity":1,"message":"201","line":48,"column":9,"nodeType":"180","messageId":"181","endLine":48,"endColumn":28},{"ruleId":"178","severity":1,"message":"202","line":6,"column":32,"nodeType":"180","messageId":"181","endLine":6,"endColumn":39},{"ruleId":"178","severity":1,"message":"203","line":2,"column":9,"nodeType":"180","messageId":"181","endLine":2,"endColumn":24},{"ruleId":"178","severity":1,"message":"204","line":23,"column":9,"nodeType":"180","messageId":"181","endLine":23,"endColumn":22},{"ruleId":"178","severity":1,"message":"205","line":3,"column":8,"nodeType":"180","messageId":"181","endLine":3,"endColumn":26},{"ruleId":"178","severity":1,"message":"203","line":2,"column":9,"nodeType":"180","messageId":"181","endLine":2,"endColumn":24},{"ruleId":"178","severity":1,"message":"206","line":9,"column":9,"nodeType":"180","messageId":"181","endLine":9,"endColumn":19},{"ruleId":"178","severity":1,"message":"207","line":10,"column":9,"nodeType":"180","messageId":"181","endLine":10,"endColumn":18},{"ruleId":"178","severity":1,"message":"208","line":11,"column":9,"nodeType":"180","messageId":"181","endLine":11,"endColumn":21},{"ruleId":"178","severity":1,"message":"209","line":12,"column":9,"nodeType":"180","messageId":"181","endLine":12,"endColumn":18},{"ruleId":"178","severity":1,"message":"210","line":7,"column":8,"nodeType":"180","messageId":"181","endLine":7,"endColumn":26},{"ruleId":"178","severity":1,"message":"203","line":2,"column":10,"nodeType":"180","messageId":"181","endLine":2,"endColumn":25},{"ruleId":"178","severity":1,"message":"206","line":8,"column":9,"nodeType":"180","messageId":"181","endLine":8,"endColumn":19},{"ruleId":"178","severity":1,"message":"207","line":9,"column":9,"nodeType":"180","messageId":"181","endLine":9,"endColumn":18},{"ruleId":"178","severity":1,"message":"208","line":10,"column":9,"nodeType":"180","messageId":"181","endLine":10,"endColumn":21},{"ruleId":"178","severity":1,"message":"209","line":11,"column":9,"nodeType":"180","messageId":"181","endLine":11,"endColumn":18},"no-unused-vars","'Board' is defined but never used.","Identifier","unusedVar","'putDownPiece' is defined but never used.","'checkWinning' is defined but never used.","'useState' is defined but never used.","'moveEvaluation' is defined but never used.","'Component' is defined but never used.","no-lone-blocks","Block is redundant.","BlockStatement","redundantBlock","'initdrawCheckBoard' is defined but never used.","'drawCheckBoard' is defined but never used.","'NavButton' is defined but never used.","'FunctionButton' is defined but never used.","'chooseRandomMove' is defined but never used.","'ShowText' is defined but never used.","'minimaxNR' is defined but never used.","'minimaxNoReductionNoDF' is defined but never used.","'minimaxMoveLimit' is defined but never used.","'minimaxAB' is defined but never used.","'gamePerformanceList' is assigned a value but never used.","'shuffle' is defined but never used.","'copyTwoDimArray' is defined but never used.","'moveWithScore' is defined but never used.","'ComputerVsComputer' is defined but never used.","'threeCount' is assigned a value but never used.","'fourCount' is assigned a value but never used.","'fourOneCount' is assigned a value but never used.","'fiveCount' is assigned a value but never used.","'moveEvaluationNoDF' is defined but never used."]