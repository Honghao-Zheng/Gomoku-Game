{"ast":null,"code":"import moveEvaluation from \"./MoveEvaluation\";\nimport initIndMoves from \"./InitIndMoves\";\nimport { individual } from \"./Objects\";\nimport { swapColor, putDownPiece } from \"../../GameLogic.jsx\";\nimport { copyTwoDimArray, random, shuffle } from \"../../GeneralAlgorithms.jsx\"; //fitness function\n\nfunction fitness(moveComb, pieceColor, defFactor, board) {\n  let index;\n  let turn = pieceColor;\n  let totalFitnessScore = 0;\n  let moveMade;\n  let boardCopy = copyTwoDimArray(board);\n\n  for (index = 0; index < moveComb.length; index++) {\n    moveMade = moveComb[index]; //discard illegal moveComb\n\n    if (boardCopy[moveMade[0]][moveMade[1]] === \" \" && moveMade[0] < 15 && moveMade[0] >= 0 && moveMade[1] < 15 && moveMade[1] >= 0) {\n      putDownPiece(moveMade, turn, boardCopy);\n\n      if (turn === pieceColor) {\n        totalFitnessScore += moveEvaluation(moveMade, turn, defFactor, boardCopy);\n      } else {\n        totalFitnessScore -= moveEvaluation(moveMade, turn, defFactor, boardCopy);\n      }\n\n      turn = swapColor(turn);\n    } else {\n      return -10000;\n    }\n\n    return totalFitnessScore;\n  }\n} // function createUniformRandomArr(size){\n//     let arr=[]\n//     for(var i=0;i<size;i++){\n//         arr.push(random(2))\n//     }\n// }\n\n\nfunction uniformCrossover(mom, dad) {\n  let child1 = new individual();\n  let child2 = new individual();\n  let child1Moves = [];\n  let child2Moves = [];\n  let randomBit;\n  let momCopy = copyTwoDimArray(mom.moveComb);\n  let dadCopy = copyTwoDimArray(dad.moveComb); // console.log(momCopy)\n  // console.log(dadCopy)\n\n  for (var moveIndex = 0; moveIndex < momCopy.length; moveIndex++) {\n    randomBit = random(2);\n\n    if (randomBit === 1) {\n      child1Moves.push(momCopy.moveComb[moveIndex]);\n      child2Moves.push(dadCopy.moveComb[moveIndex]);\n    }\n\n    if (randomBit === 0) {\n      child1Moves.push(dadCopy.moveComb[moveIndex]);\n      child2Moves.push(momCopy.moveComb[moveIndex]);\n    }\n  }\n\n  child1.moveComb = child1Moves;\n  child2.moveComb = child2Moves;\n  return [child1, child2];\n}\n\nfunction mutate(ind, prop) {\n  let randomNum;\n  let moveIndex;\n  let mutationChange = [-1, 1];\n  let rowMuation, colMutation;\n  let moveMutated;\n\n  for (moveIndex = 0; moveIndex < ind.moveComb.length; moveIndex++) {\n    randomNum = Math.random();\n\n    if (randomNum < prop) {\n      rowMuation = mutationChange[random(2)];\n      colMutation = mutationChange[random(2)];\n      moveMutated = ind.moveComb[moveIndex];\n      ind.moveComb[moveIndex] = [moveMutated[0] + rowMuation, moveMutated[1] + colMutation];\n    }\n  }\n}\n\nfunction sortPopulation(population) {\n  population.sort((ind1, ind2) => ind2.score - ind1.score);\n}\n\nfunction createDumyIterationArray(numOfIteration) {\n  let array = [];\n\n  for (var i = 0; i < numOfIteration; i++) {\n    array.push(i);\n  }\n\n  return array;\n}\n\nfunction GAmove(pieceColor, board) {\n  console.log(pieceColor);\n  let numOfPopulation = 500;\n  let numOfIteration = 100;\n  let numOfChildren = 500;\n  let population = [];\n  let depth = 5;\n  let mutateProp = 0.1;\n  let defFactor = 0.6;\n  let ind;\n  let it;\n  let childIndex;\n  let bestInd;\n  let bestScore = 0;\n  let produceChildIt = Math.floor(numOfChildren / 2);\n  let mom, momIndex;\n  let dad, dadIndex;\n  let dumyIterationArray;\n  let child1, child2; //initialise population\n\n  for (var i = 0; i < numOfPopulation; i++) {\n    ind = new individual();\n    ind.moveComb = initIndMoves(pieceColor, depth, board);\n    ind.score = fitness(ind.moveComb, pieceColor, defFactor, board);\n    population.push(ind);\n\n    if (ind.score > bestScore) {\n      bestInd = new individual();\n      bestInd.moveComb = ind.moveComb;\n      bestInd.score = ind.score;\n    }\n  } // console.log(population[0].moveComb)\n  // console.log(\"forst ind in population: \"+population[0].moveComb)\n  //iterations\n\n\n  for (it = 0; it <= numOfIteration; it++) {\n    for (childIndex = 0; childIndex < produceChildIt; childIndex++) {\n      //choose random parents in the population\n      dumyIterationArray = createDumyIterationArray(numOfIteration);\n      shuffle(dumyIterationArray);\n      momIndex = dumyIterationArray[0];\n      dadIndex = dumyIterationArray[1];\n      mom = population[momIndex];\n      dad = population[dadIndex]; //produce two childen\n\n      [child1, child2] = uniformCrossover(mom, dad); //mutate two childen\n\n      mutate(child1, mutateProp);\n      mutate(child2, mutateProp); //evaluate the child performance\n\n      child1.score = fitness(child1.moveComb, pieceColor, defFactor, board);\n\n      if (child1.score > bestScore) {\n        bestInd = new individual();\n        bestInd.moveComb = child1.moveComb;\n        bestInd.score = child1.score;\n      }\n\n      child2.score = fitness(child2.moveComb, pieceColor, defFactor, board);\n\n      if (child2.score > bestScore) {\n        bestInd = new individual();\n        bestInd.moveComb = child2.moveComb;\n        bestInd.score = child2.score;\n      } //add the child to population\n\n\n      population.push(child1);\n      population.push(child2); //sort population in descending order\n    }\n\n    sortPopulation(population);\n    population = population.slice(0, numOfPopulation - 1);\n  }\n\n  return bestInd.moveComb[0];\n}\n\n_c = GAmove;\nexport default GAmove;\n\nvar _c;\n\n$RefreshReg$(_c, \"GAmove\");","map":{"version":3,"names":["moveEvaluation","initIndMoves","individual","swapColor","putDownPiece","copyTwoDimArray","random","shuffle","fitness","moveComb","pieceColor","defFactor","board","index","turn","totalFitnessScore","moveMade","boardCopy","length","uniformCrossover","mom","dad","child1","child2","child1Moves","child2Moves","randomBit","momCopy","dadCopy","moveIndex","push","mutate","ind","prop","randomNum","mutationChange","rowMuation","colMutation","moveMutated","Math","sortPopulation","population","sort","ind1","ind2","score","createDumyIterationArray","numOfIteration","array","i","GAmove","console","log","numOfPopulation","numOfChildren","depth","mutateProp","it","childIndex","bestInd","bestScore","produceChildIt","floor","momIndex","dadIndex","dumyIterationArray","slice"],"sources":["C:/Users/Jason/Desktop/MSc project/project/gomoku/src/components/AIplayers/GA/GAalgorithm.jsx"],"sourcesContent":["import moveEvaluation from \"./MoveEvaluation\";\r\nimport initIndMoves from \"./InitIndMoves\";\r\nimport {individual} from \"./Objects\";\r\nimport {swapColor,putDownPiece} from \"../../GameLogic.jsx\"\r\nimport {copyTwoDimArray,random,shuffle} from \"../../GeneralAlgorithms.jsx\"\r\n//fitness function\r\n\r\nfunction fitness(moveComb,pieceColor,defFactor,board){\r\n    let index;\r\n    let turn=pieceColor;\r\n    let totalFitnessScore=0;\r\n    let moveMade;\r\n    let boardCopy=copyTwoDimArray(board);\r\n    for(index=0;index<moveComb.length;index++){\r\n        moveMade=moveComb[index];\r\n        //discard illegal moveComb\r\n        if(boardCopy[moveMade[0]][moveMade[1]] ===\" \" \r\n            && moveMade[0]<15 && moveMade[0]>=0 && moveMade[1]<15 && moveMade[1]>=0){\r\n                putDownPiece(moveMade,turn,boardCopy)\r\n                if(turn===pieceColor){\r\n                    totalFitnessScore+=moveEvaluation(moveMade,turn,defFactor,boardCopy)\r\n                } else{\r\n                    totalFitnessScore-=moveEvaluation(moveMade,turn,defFactor,boardCopy)\r\n                }\r\n        \r\n                turn=swapColor(turn)\r\n        } else{\r\n            return -10000;\r\n        }\r\n\r\n        return totalFitnessScore\r\n\r\n    }\r\n}\r\n\r\n// function createUniformRandomArr(size){\r\n//     let arr=[]\r\n//     for(var i=0;i<size;i++){\r\n//         arr.push(random(2))\r\n//     }\r\n// }\r\n\r\nfunction uniformCrossover(mom,dad){\r\n    let child1=new individual();\r\n    let child2=new individual();\r\n    let child1Moves=[];\r\n    let child2Moves=[];\r\n    let randomBit;\r\n    let momCopy=copyTwoDimArray(mom.moveComb);\r\n    let dadCopy=copyTwoDimArray(dad.moveComb);\r\n    // console.log(momCopy)\r\n    // console.log(dadCopy)\r\n    \r\n    for(var moveIndex=0;moveIndex<momCopy.length;moveIndex++){\r\n        randomBit=random(2);\r\n        if (randomBit===1){\r\n            child1Moves.push(momCopy.moveComb[moveIndex])\r\n            child2Moves.push(dadCopy.moveComb[moveIndex])\r\n        }\r\n        if (randomBit===0){\r\n            child1Moves.push(dadCopy.moveComb[moveIndex])\r\n            child2Moves.push(momCopy.moveComb[moveIndex])\r\n        }\r\n\r\n    }\r\n    child1.moveComb=child1Moves\r\n    child2.moveComb=child2Moves\r\n    return [child1,child2]\r\n}\r\n\r\n\r\nfunction mutate(ind,prop){\r\n    let randomNum;\r\n    let moveIndex;\r\n    let mutationChange=[-1,1]\r\n    let rowMuation,colMutation;\r\n    let moveMutated;\r\n    for (moveIndex=0;moveIndex<ind.moveComb.length;moveIndex++){\r\n        randomNum=Math.random();\r\n        if (randomNum<prop){\r\n            rowMuation=mutationChange[random(2)]\r\n            colMutation=mutationChange[random(2)]\r\n            moveMutated=ind.moveComb[moveIndex]\r\n            ind.moveComb[moveIndex]=[moveMutated[0]+rowMuation,moveMutated[1]+colMutation]  \r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction sortPopulation(population){\r\n    population.sort((ind1,ind2)=>ind2.score-ind1.score)\r\n}\r\n\r\nfunction createDumyIterationArray(numOfIteration){\r\n    let array=[]\r\n    for (var i=0;i<numOfIteration;i++){\r\n        array.push(i)\r\n    }\r\n    return array\r\n}\r\n\r\nfunction GAmove(pieceColor,board){\r\n    console.log(pieceColor)\r\nlet numOfPopulation=500;\r\nlet numOfIteration=100;\r\nlet numOfChildren=500;\r\nlet population=[]\r\nlet depth=5;\r\nlet mutateProp=0.1\r\nlet defFactor=0.6;\r\nlet ind;\r\nlet it;\r\nlet childIndex;\r\nlet bestInd;\r\nlet bestScore=0\r\nlet produceChildIt=Math.floor(numOfChildren/2)\r\nlet mom,momIndex;\r\nlet dad,dadIndex;\r\nlet dumyIterationArray;\r\nlet child1,child2;\r\n\r\n\r\n\r\n//initialise population\r\nfor (var i=0;i<numOfPopulation;i++){\r\n    ind=new individual();\r\n    ind.moveComb=initIndMoves(pieceColor,depth,board)\r\n    \r\n    ind.score=fitness(ind.moveComb,pieceColor,defFactor,board)\r\n    population.push(ind)\r\n    if (ind.score>bestScore){\r\n        bestInd=new individual();\r\n        bestInd.moveComb=ind.moveComb;\r\n        bestInd.score=ind.score;\r\n    }\r\n}\r\n// console.log(population[0].moveComb)\r\n// console.log(\"forst ind in population: \"+population[0].moveComb)\r\n//iterations\r\nfor (it=0;it<=numOfIteration;it++){\r\n    for (childIndex=0;childIndex<produceChildIt;childIndex++){\r\n        //choose random parents in the population\r\n        dumyIterationArray=createDumyIterationArray(numOfIteration);\r\n        shuffle(dumyIterationArray);\r\n        momIndex=dumyIterationArray[0]\r\n        dadIndex=dumyIterationArray[1]\r\n        mom=population[momIndex];\r\n        dad=population[dadIndex];\r\n\r\n        //produce two childen\r\n        [child1,child2]=uniformCrossover(mom,dad)\r\n        //mutate two childen\r\n        mutate(child1,mutateProp)\r\n        mutate(child2,mutateProp)\r\n        //evaluate the child performance\r\n        child1.score=fitness(child1.moveComb,pieceColor,defFactor,board)\r\n        if(child1.score>bestScore){\r\n            bestInd=new individual();\r\n            bestInd.moveComb=child1.moveComb;\r\n            bestInd.score=child1.score;\r\n        }\r\n        child2.score=fitness(child2.moveComb,pieceColor,defFactor,board)\r\n        if(child2.score>bestScore){\r\n            bestInd=new individual();\r\n            bestInd.moveComb=child2.moveComb;\r\n            bestInd.score=child2.score;\r\n        }\r\n        //add the child to population\r\n        population.push(child1)\r\n        population.push(child2)\r\n        //sort population in descending order\r\n    }\r\n    sortPopulation(population)\r\n    population=population.slice(0, numOfPopulation-1)\r\n    \r\n\r\n}\r\nreturn bestInd.moveComb[0]\r\n}\r\n\r\nexport default GAmove;"],"mappings":"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"},"metadata":{},"sourceType":"module"}