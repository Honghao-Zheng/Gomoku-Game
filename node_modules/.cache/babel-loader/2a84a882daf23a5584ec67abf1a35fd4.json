{"ast":null,"code":"import moveEvaluation from \"./MoveEvaluation\";\nimport initIndMoves from \"./InitIndMoves\";\nimport { individual } from \"./Objects\";\nimport { swapColor, putDownPiece } from \"../../GameLogic.jsx\";\nimport { copyTwoDimArray, random, shuffle } from \"../../GeneralAlgorithms.jsx\"; //fitness function\n\nfunction fitness(moveComb, pieceColor, defFactor, board) {\n  let index;\n  let turn = pieceColor;\n  let totalFitnessScore = 0;\n  let moveMade;\n  let boardCopy = copyTwoDimArray(board);\n  console.log(\"moveComb1: \" + moveComb);\n\n  for (index = 0; index < moveComb.length; index++) {\n    moveMade = moveComb[index]; //discard illegal moveComb\n\n    if (moveMade[0] < 15 && moveMade[0] >= 0 && moveMade[1] < 15 && moveMade[1] >= 0) {\n      if (boardCopy[moveMade[0]][moveMade[1]] === \" \") {\n        putDownPiece(moveMade, turn, boardCopy);\n\n        if (turn === pieceColor) {\n          totalFitnessScore += moveEvaluation(moveMade, turn, defFactor, boardCopy);\n        } else {\n          totalFitnessScore -= moveEvaluation(moveMade, turn, defFactor, boardCopy);\n        }\n\n        turn = swapColor(turn);\n      } else {\n        return -10000;\n      }\n    } else {\n      return -10000;\n    }\n\n    return totalFitnessScore;\n  }\n} // function createUniformRandomArr(size){\n//     let arr=[]\n//     for(var i=0;i<size;i++){\n//         arr.push(random(2))\n//     }\n// }\n\n\nfunction uniformCrossover(mom, dad) {\n  let child1 = new individual();\n  let child2 = new individual();\n  let child1Moves = [];\n  let child2Moves = [];\n  let randomBit;\n  let momCopy = copyTwoDimArray(mom.moveComb);\n  let dadCopy = copyTwoDimArray(dad.moveComb); // console.log(mom.moveComb)\n  // console.log(dad.moveComb)\n\n  for (var moveIndex = 0; moveIndex < momCopy.length; moveIndex++) {\n    randomBit = random(2);\n\n    if (randomBit === 1) {\n      child1Moves.push(momCopy[moveIndex]);\n      child2Moves.push(dadCopy[moveIndex]);\n    }\n\n    if (randomBit === 0) {\n      child1Moves.push(dadCopy[moveIndex]);\n      child2Moves.push(momCopy[moveIndex]);\n    }\n  }\n\n  child1.moveComb = child1Moves;\n  child2.moveComb = child2Moves;\n  return [child1, child2];\n}\n\nfunction mutate(ind, prop) {\n  let randomNum;\n  let moveIndex;\n  let mutationChange = [-1, 1];\n  let rowMuation, colMutation;\n  let moveMutated;\n\n  for (moveIndex = 0; moveIndex < ind.moveComb.length; moveIndex++) {\n    randomNum = Math.random();\n\n    if (randomNum < prop) {\n      rowMuation = mutationChange[random(2)];\n      colMutation = mutationChange[random(2)];\n      moveMutated = ind.moveComb[moveIndex];\n      ind.moveComb[moveIndex] = [moveMutated[0] + rowMuation, moveMutated[1] + colMutation];\n    }\n  }\n}\n\nfunction sortPopulation(population) {\n  population.sort((ind1, ind2) => ind2.score - ind1.score);\n}\n\nfunction createDumyIterationArray(numOfIteration) {\n  let array = [];\n\n  for (var i = 0; i < numOfIteration; i++) {\n    array.push(i);\n  }\n\n  return array;\n}\n\nfunction GAmove(pieceColor, board) {\n  console.log(pieceColor);\n  let numOfPopulation = 5;\n  let numOfIteration = 1;\n  let numOfChildren = 5;\n  let population = [];\n  let depth = 5;\n  let mutateProp = 0.1;\n  let defFactor = 0.6;\n  let ind;\n  let it;\n  let childIndex;\n  let bestInd;\n  let bestScore = 0;\n  let produceChildIt = Math.floor(numOfChildren / 2);\n  let mom, momIndex;\n  let dad, dadIndex;\n  let dumyIterationArray;\n  let child1, child2; //initialise population\n\n  for (var i = 0; i < numOfPopulation; i++) {\n    ind = new individual();\n    ind.moveComb = initIndMoves(pieceColor, depth, board);\n    ind.score = fitness(ind.moveComb, pieceColor, defFactor, board);\n    population.push(ind);\n\n    if (ind.score > bestScore) {\n      bestInd = new individual();\n      bestInd.moveComb = ind.moveComb;\n      bestInd.score = ind.score;\n    }\n  } // console.log(population[0].moveComb)\n  // console.log(\"forst ind in population: \"+population[0].moveComb)\n  //iterations\n\n\n  for (it = 0; it <= numOfIteration; it++) {\n    for (childIndex = 0; childIndex < produceChildIt; childIndex++) {\n      //choose random parents in the population\n      dumyIterationArray = createDumyIterationArray(numOfIteration);\n      shuffle(dumyIterationArray);\n      momIndex = dumyIterationArray[0];\n      dadIndex = dumyIterationArray[1];\n      mom = population[momIndex];\n      dad = population[dadIndex]; //produce two childen\n\n      [child1, child2] = uniformCrossover(mom, dad); //mutate two childen\n\n      mutate(child1, mutateProp);\n      mutate(child2, mutateProp); //evaluate the child performance\n\n      child1.score = fitness(child1.moveComb, pieceColor, defFactor, board);\n\n      if (child1.score > bestScore) {\n        bestInd = new individual();\n        bestInd.moveComb = child1.moveComb;\n        bestInd.score = child1.score;\n      }\n\n      child2.score = fitness(child2.moveComb, pieceColor, defFactor, board);\n\n      if (child2.score > bestScore) {\n        bestInd = new individual();\n        bestInd.moveComb = child2.moveComb;\n        bestInd.score = child2.score;\n      } //add the child to population\n\n\n      population.push(child1);\n      population.push(child2); //sort population in descending order\n    }\n\n    sortPopulation(population);\n    population = population.slice(0, numOfPopulation - 1);\n  }\n\n  return bestInd.moveComb[0];\n}\n\n_c = GAmove;\nexport default GAmove;\n\nvar _c;\n\n$RefreshReg$(_c, \"GAmove\");","map":{"version":3,"names":["moveEvaluation","initIndMoves","individual","swapColor","putDownPiece","copyTwoDimArray","random","shuffle","fitness","moveComb","pieceColor","defFactor","board","index","turn","totalFitnessScore","moveMade","boardCopy","console","log","length","uniformCrossover","mom","dad","child1","child2","child1Moves","child2Moves","randomBit","momCopy","dadCopy","moveIndex","push","mutate","ind","prop","randomNum","mutationChange","rowMuation","colMutation","moveMutated","Math","sortPopulation","population","sort","ind1","ind2","score","createDumyIterationArray","numOfIteration","array","i","GAmove","numOfPopulation","numOfChildren","depth","mutateProp","it","childIndex","bestInd","bestScore","produceChildIt","floor","momIndex","dadIndex","dumyIterationArray","slice"],"sources":["C:/Users/Jason/Desktop/hxz157/gomoku/src/components/AIplayers/GA/GAalgorithm.jsx"],"sourcesContent":["import moveEvaluation from \"./MoveEvaluation\";\r\nimport initIndMoves from \"./InitIndMoves\";\r\nimport {individual} from \"./Objects\";\r\nimport {swapColor,putDownPiece} from \"../../GameLogic.jsx\"\r\nimport {copyTwoDimArray,random,shuffle} from \"../../GeneralAlgorithms.jsx\"\r\n//fitness function\r\n\r\nfunction fitness(moveComb,pieceColor,defFactor,board){\r\n    let index;\r\n    let turn=pieceColor;\r\n    let totalFitnessScore=0;\r\n    let moveMade;\r\n    let boardCopy=copyTwoDimArray(board);\r\n    console.log(\"moveComb1: \"+moveComb)\r\n    for(index=0;index<moveComb.length;index++){\r\n        moveMade=moveComb[index];\r\n        //discard illegal moveComb\r\n        if(\r\n            moveMade[0]<15 && moveMade[0]>=0 && moveMade[1]<15 && moveMade[1]>=0){\r\n                if(boardCopy[moveMade[0]][moveMade[1]] ===\" \"){\r\n                    putDownPiece(moveMade,turn,boardCopy)\r\n                    if(turn===pieceColor){\r\n                        totalFitnessScore+=moveEvaluation(moveMade,turn,defFactor,boardCopy)\r\n                    } else{\r\n                        totalFitnessScore-=moveEvaluation(moveMade,turn,defFactor,boardCopy)\r\n                    }\r\n            \r\n                    turn=swapColor(turn)\r\n                } else {\r\n                    return -10000\r\n                }\r\n\r\n        } else{\r\n            return -10000;\r\n        }\r\n\r\n        return totalFitnessScore\r\n\r\n    }\r\n}\r\n\r\n// function createUniformRandomArr(size){\r\n//     let arr=[]\r\n//     for(var i=0;i<size;i++){\r\n//         arr.push(random(2))\r\n//     }\r\n// }\r\n\r\nfunction uniformCrossover(mom,dad){\r\n    let child1=new individual();\r\n    let child2=new individual();\r\n    let child1Moves=[];\r\n    let child2Moves=[];\r\n    let randomBit;\r\n    let momCopy=copyTwoDimArray(mom.moveComb);\r\n    let dadCopy=copyTwoDimArray(dad.moveComb);\r\n    // console.log(mom.moveComb)\r\n    // console.log(dad.moveComb)\r\n    \r\n    for(var moveIndex=0;moveIndex<momCopy.length;moveIndex++){\r\n        randomBit=random(2);\r\n        if (randomBit===1){\r\n            child1Moves.push(momCopy[moveIndex])\r\n            child2Moves.push(dadCopy[moveIndex])\r\n        }\r\n        if (randomBit===0){\r\n            child1Moves.push(dadCopy[moveIndex])\r\n            child2Moves.push(momCopy[moveIndex])\r\n        }\r\n\r\n    }\r\n    child1.moveComb=child1Moves\r\n    child2.moveComb=child2Moves\r\n    return [child1,child2]\r\n}\r\n\r\n\r\nfunction mutate(ind,prop){\r\n    let randomNum;\r\n    let moveIndex;\r\n    let mutationChange=[-1,1]\r\n    let rowMuation,colMutation;\r\n    let moveMutated;\r\n    for (moveIndex=0;moveIndex<ind.moveComb.length;moveIndex++){\r\n        randomNum=Math.random();\r\n        if (randomNum<prop){\r\n            rowMuation=mutationChange[random(2)]\r\n            colMutation=mutationChange[random(2)]\r\n            moveMutated=ind.moveComb[moveIndex]\r\n            ind.moveComb[moveIndex]=[moveMutated[0]+rowMuation,moveMutated[1]+colMutation]  \r\n        }\r\n    }\r\n\r\n}\r\n\r\nfunction sortPopulation(population){\r\n    population.sort((ind1,ind2)=>ind2.score-ind1.score)\r\n}\r\n\r\nfunction createDumyIterationArray(numOfIteration){\r\n    let array=[]\r\n    for (var i=0;i<numOfIteration;i++){\r\n        array.push(i)\r\n    }\r\n    return array\r\n}\r\n\r\nfunction GAmove(pieceColor,board){\r\n    console.log(pieceColor)\r\nlet numOfPopulation=5;\r\nlet numOfIteration=1;\r\nlet numOfChildren=5;\r\nlet population=[]\r\nlet depth=5;\r\nlet mutateProp=0.1\r\nlet defFactor=0.6;\r\nlet ind;\r\nlet it;\r\nlet childIndex;\r\nlet bestInd;\r\nlet bestScore=0\r\nlet produceChildIt=Math.floor(numOfChildren/2)\r\nlet mom,momIndex;\r\nlet dad,dadIndex;\r\nlet dumyIterationArray;\r\nlet child1,child2;\r\n\r\n\r\n\r\n//initialise population\r\nfor (var i=0;i<numOfPopulation;i++){\r\n    ind=new individual();\r\n    ind.moveComb=initIndMoves(pieceColor,depth,board)\r\n    \r\n    ind.score=fitness(ind.moveComb,pieceColor,defFactor,board)\r\n    population.push(ind)\r\n    if (ind.score>bestScore){\r\n        bestInd=new individual();\r\n        bestInd.moveComb=ind.moveComb;\r\n        bestInd.score=ind.score;\r\n    }\r\n}\r\n// console.log(population[0].moveComb)\r\n// console.log(\"forst ind in population: \"+population[0].moveComb)\r\n//iterations\r\nfor (it=0;it<=numOfIteration;it++){\r\n    for (childIndex=0;childIndex<produceChildIt;childIndex++){\r\n        //choose random parents in the population\r\n        dumyIterationArray=createDumyIterationArray(numOfIteration);\r\n        shuffle(dumyIterationArray);\r\n        momIndex=dumyIterationArray[0]\r\n        dadIndex=dumyIterationArray[1]\r\n        mom=population[momIndex];\r\n        dad=population[dadIndex];\r\n\r\n        //produce two childen\r\n        [child1,child2]=uniformCrossover(mom,dad)\r\n        //mutate two childen\r\n        mutate(child1,mutateProp)\r\n        mutate(child2,mutateProp)\r\n        //evaluate the child performance\r\n        child1.score=fitness(child1.moveComb,pieceColor,defFactor,board)\r\n        if(child1.score>bestScore){\r\n            bestInd=new individual();\r\n            bestInd.moveComb=child1.moveComb;\r\n            bestInd.score=child1.score;\r\n        }\r\n        child2.score=fitness(child2.moveComb,pieceColor,defFactor,board)\r\n        if(child2.score>bestScore){\r\n            bestInd=new individual();\r\n            bestInd.moveComb=child2.moveComb;\r\n            bestInd.score=child2.score;\r\n        }\r\n        //add the child to population\r\n        population.push(child1)\r\n        population.push(child2)\r\n        //sort population in descending order\r\n    }\r\n    sortPopulation(population)\r\n    population=population.slice(0, numOfPopulation-1)\r\n    \r\n\r\n}\r\nreturn bestInd.moveComb[0]\r\n}\r\n\r\nexport default GAmove;"],"mappings":"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"},"metadata":{},"sourceType":"module"}